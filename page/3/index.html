<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="czh的学习小站">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="czh的学习小站">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蔡正海">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>czh的学习小站</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">czh的学习小站</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">自律</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蔡正海"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蔡正海</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/31/kaifa/bagu/springIOC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="蔡正海">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="czh的学习小站">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | czh的学习小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/31/kaifa/bagu/springIOC/" class="post-title-link" itemprop="url">【1开发】【八股】springIOC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a></p>
<p><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html#ioc-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html#ioc-解决了什么问题</a></p>
</blockquote>
<h2 id="知乎的一个非常典型的例子"><a href="#知乎的一个非常典型的例子" class="headerlink" title="知乎的一个非常典型的例子"></a>知乎的一个非常典型的例子</h2><p>IOC是<strong>依赖倒置原则</strong>的体现，是为了处理工程中的依赖关系。</p>
<p>知乎的这个例子很好地解释了“依赖注入”的注入是什么。</p>
<img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/v2-82e0c12a1b26f7979ed9241e169affda_1440w.webp" alt="img" style="zoom:50%;" />

<p>这种方式是不好的，为什么？假如最末尾一个类的构造方法改了，完蛋，全部类的构造方法都要改。这种工程是不可维护的。</p>
<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/v2-c920a0540ce0651003a5326f6ef9891d_1440w.webp" alt="img"></p>
<p>所以我们怎么办呢，当然就用我们的依赖注入：就是<strong>把底层类作为参数传入上层类</strong>。实现上层类对下层类的控制。</p>
<h2 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h2><p>我们在springboot项目中</p>
<ul>
<li>不管是Dao，还是外部包的那些config</li>
<li>我们从来都不会通过<strong>new</strong>的方式来创建，而是通过依赖注入的方式。</li>
<li><strong>你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化一辆车都要亲手去写那一大段初始化的代码</strong></li>
</ul>
<p>控制反转（描述的是对象的创建以及管理的问题）</p>
<ul>
<li>控制：对象创建的权利</li>
<li>反转：控制权交给外部环境IOC容器</li>
</ul>
<p>好处</p>
<ul>
<li>对象之间的依赖程度降低</li>
<li>资源变的容易管理<ul>
<li>单例模式</li>
<li>IOC容器负责bean的整个生命周期</li>
</ul>
</li>
</ul>
<h2 id="IOC原理"><a href="#IOC原理" class="headerlink" title="IOC原理"></a>IOC原理</h2><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240708103644862.png" alt="image-20240708103644862" style="zoom:50%;" />

<ol>
<li>FileSystemXmlApplicationContext&#x2F;ClassPathXmlApplicationContext ：xml配置文件在系统中的路径</li>
<li>AnnotationConfigApplicationContext：基于注解来使用</li>
</ol>
<h3 id="一个小例子"><a href="#一个小例子" class="headerlink" title="一个小例子"></a>一个小例子</h3><p>使用 ClassPathXmlApplicationContext 进行分析，方便理解整个构建流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用我们的配置文件来启动一个 ApplicationContext</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:application.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;context 启动成功&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span></span><br><span class="line"><span class="type">MessageService</span> <span class="variable">messageService</span> <span class="operator">=</span> context.getBean(MessageService.class);</span><br><span class="line">System.out.println(messageService.getMessage());</span><br></pre></td></tr></table></figure>

<p>那么，这里我们通过ApplicationContext拿到了Bean。那么ApplicationContext是如何创建实例Bean，并且往各个Bean中注入依赖的呢？</p>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240708105257053.png" alt="image-20240708105257053" style="zoom:33%;" />

<p>ApplicationContext其实就是一个BeanFactory</p>
<h3 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h3><h4 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h4><p>先从构造方法开始，把configLocations（也就是XML地址）读进来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="type">boolean</span> refresh, ApplicationContext parent)</span></span><br><span class="line">		<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">super</span>(parent);</span><br><span class="line">	setConfigLocations(configLocations);</span><br><span class="line">	<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">		refresh();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-refresh-方法-–-（BeanFactory注册BeanDefinition-初始化所有单例beans"><a href="#2-refresh-方法-–-（BeanFactory注册BeanDefinition-初始化所有单例beans" class="headerlink" title="2. refresh()方法 – （BeanFactory注册BeanDefinition+初始化所有单例beans)"></a>2. refresh()方法 – （BeanFactory注册BeanDefinition+初始化所有单例beans)</h4><blockquote>
<ol>
<li>插一嘴，BeanFactory当然是Bean容器，那么Bean是什么呢？它其实准确来说叫BeanDefinition，我们自己定义的一个个Bean会转换成一个个BeanDefinition存在于Spring的BeanFactory中。</li>
<li>BeanDefinition保存了所有的Bean信息：是哪个类，是否是单例的，等等</li>
<li>所以，Bean是什么？在代码层面可以理解为：BeanDefinition的实例</li>
</ol>
</blockquote>
<p>（太复杂，以后再慢慢看吧，先看核心的几步）</p>
<ul>
<li>obtainFreshBeanFactory（拿到BeanFactory）<ul>
<li>这代表applicationContext其实内部持有了一个BeanFactory</li>
<li>BeanDefinition注册到了BeanFactory中</li>
<li>我们可以看到里面维护了一个<strong>ConcurrentHashMap</strong>，存beanName-&gt; beanDefinition</li>
<li><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240708165122143.png" alt="image-20240708165122143"></li>
</ul>
</li>
<li>finishBeanFactoryInitialization（创建所有单例Bean，也就是getBean方法）<ul>
<li><strong>实例化</strong>：使用反射创建Bean实例。</li>
<li><strong>依赖注入</strong>：根据Bean定义中的依赖关系，将所需的依赖注入到Bean实例中。<ul>
<li>（这里就是依赖倒置的概念，dfs，从上层往下层搜索，知乎的那个教程里写的）</li>
<li><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240708171643710.png" alt="image-20240708171643710"></li>
</ul>
</li>
<li><strong>初始化</strong>：调用Bean的初始化方法（如配置的init-method或实现了InitializingBean接口的afterPropertiesSet方法）。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">			。。。。。。</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line">  </span><br><span class="line">  		。。。。。。</span><br><span class="line">        <span class="comment">// 重点，重点，重点</span></span><br><span class="line">        <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">        <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">        finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/31/kaifa/bagu/springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="蔡正海">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="czh的学习小站">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | czh的学习小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/31/kaifa/bagu/springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">【1开发】【八股】springboot自动配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Springboot-自动配置是啥"><a href="#Springboot-自动配置是啥" class="headerlink" title="Springboot 自动配置是啥"></a>Springboot 自动配置是啥</h2><p>举两个例子</p>
<ol>
<li>我在dbrouter里有这样一个类DataSourceAutoConfig，在spring.factories里配置了EnableAutoConfiguration</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfig</span> <span class="keyword">implements</span> <span class="title class_">EnvironmentAware</span></span><br><span class="line"><span class="comment">//spring.factories</span></span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=cn.czh.middleware.db.router.config.DataSourceAutoConfig</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在项目中，有一个RedisClientConfig类，有@Configuration注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisClientConfigProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClientConfig</span> </span><br><span class="line"><span class="comment">//spring.factories</span></span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=org.redisson.spring.starter.RedissonAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>这种形式就叫自动配置（顾名思义，配置作用当然就是省去繁琐的XML-bean配置，引入外部jar包加上几个注解就完事。至于jar包中有哪些自动配置类，类名是啥这些用户都不关心）</p>
<h3 id="简单看看，一个自动配置的Config里应该包含什么"><a href="#简单看看，一个自动配置的Config里应该包含什么" class="headerlink" title="简单看看，一个自动配置的Config里应该包含什么"></a>简单看看，一个自动配置的Config里应该包含什么</h3><p>应该包含三个下面三种类型的注解</p>
<ol>
<li>@Configuration： 有了这个注解，类底下那些bean才会被spring给创建出来</li>
<li>@ConfigurationProperties：配置属性，你得把yml那些信息读进来嘛</li>
<li>@ConditionalOnClass：条件注解，当然还有很多其他的。你希望在满足一定条件的时候，这个config才有效。</li>
</ol>
<h2 id="Springboot-自动配置原理"><a href="#Springboot-自动配置原理" class="headerlink" title="Springboot 自动配置原理"></a>Springboot 自动配置原理</h2><p>看网上的资料，自动配置的核心是基于下面两个概念，扩展成@EnableAutoConfiguration：</p>
<ul>
<li>ImportSelector</li>
<li>spring.factories</li>
</ul>
<h5 id="面渣逆袭上的的一张图"><a href="#面渣逆袭上的的一张图" class="headerlink" title="面渣逆袭上的的一张图"></a>面渣逆袭上的的一张图</h5><p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/spring-df77ee15-2ff0-4ec7-8e65-e4ebb8ba88f1.png" alt="三分恶面渣逆袭：SpringBoot自动配置原理"></p>
<h3 id="要看“自动配置”，当然得先看“配置”"><a href="#要看“自动配置”，当然得先看“配置”" class="headerlink" title="要看“自动配置”，当然得先看“配置”"></a>要看“自动配置”，当然得先看“配置”</h3><p>springboot要怎么加载一个配置，方法有两个：“ComponentScan”和“Import”。</p>
<ul>
<li><p>@ComponentScan，它会自动扫描@Component、@Service、@Repository和 @Controller这些个注解</p>
<ul>
<li>还可以配置basePackages、basePackageClasses指定包和类所在的包（当然这些和这里无关）</li>
</ul>
</li>
<li><p>@Import，它有几种方法导入，我只看了前两种</p>
<ul>
<li><p>普通导入，直接把要加载的那个类通过import指定就完事</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyRepository <span class="title function_">myRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyRepository</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;AppConfig1.class, .......&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>“ImportSelector”：我们可以通过这个ImportSelector类，去告诉Import应该加载哪些东西</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyRepository <span class="title function_">myRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyRepository</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; AppConfig1.class.getName(), ...... &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一个ImportBeanDefinitionRegistrar就不看了</p>
</li>
</ul>
</li>
</ul>
<p>其实，自动配置就是通过其中一个方法实现的：是“ImportSelector”，只要selectImports能拿到要加载的类就好了。</p>
<h3 id="知道了“配置”，可以看“自动配置”了"><a href="#知道了“配置”，可以看“自动配置”了" class="headerlink" title="知道了“配置”，可以看“自动配置”了"></a>知道了“配置”，可以看“自动配置”了</h3><p>实现自动装配的核心注解，就是@EnableAutoConfiguration注解</p>
<p>当然我们在项目中看不到它，因为它藏在@SpringBootApplication中，@SpringBootApplication是三个</p>
<ul>
<li><strong>@EnableAutoConfiguration：自动装配</strong></li>
<li>@Configuration（无关）</li>
<li>@ComponentScan（无关）</li>
</ul>
<p>点进源码看的话，大概流程是：@EnableAutoConfiguration. —&gt; @import( AutoConfigurationImportSelector.class) –&gt; AutoConfigurationImportSelector的优雅实现</p>
<h4 id="1-EnableAutoConfiguration"><a href="#1-EnableAutoConfiguration" class="headerlink" title="1. EnableAutoConfiguration"></a>1. EnableAutoConfiguration</h4><p>和上一节的小例子很像，import了一个AutoConfigurationImportSelector类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure>

<h4 id="2-AutoConfigurationImportSelector"><a href="#2-AutoConfigurationImportSelector" class="headerlink" title="2. AutoConfigurationImportSelector"></a>2. AutoConfigurationImportSelector</h4><p>那么，我们也在就剩最后一件事要做。实现这个ImportSelector类，让它能发现classpath中jar包的自动配置类。</p>
<p><strong>那么，具体要怎么去发现呢，用Spring框架中的SpringFactories机制</strong></p>
<ul>
<li>核心逻辑就是去读取所有META-INF&#x2F;spring.factories，把里面的&lt;K,V&gt;对都给读出来</li>
</ul>
<h5 id="2-1-实现这个ImportSelector类，核心就是重写selectImports"><a href="#2-1-实现这个ImportSelector类，核心就是重写selectImports" class="headerlink" title="2.1 实现这个ImportSelector类，核心就是重写selectImports"></a>2.1 实现这个ImportSelector类，核心就是重写selectImports</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">		<span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">AutoConfigurationMetadata</span> <span class="variable">autoConfigurationMetadata</span> <span class="operator">=</span> AutoConfigurationMetadataLoader</span><br><span class="line">			.loadMetadata(<span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">   <span class="comment">// 自动配置的入口方法 getAutoConfigurationEntry</span></span><br><span class="line">	<span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">			annotationMetadata);</span><br><span class="line">	<span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong><u>虽然但是，网上教程都是说这里会调用String[] selectImports()方法。为什么我debug进的是public Iterable<Entry> selectImports() 方法，难道是我看的教程时间太久远了吗？先不管了。</u></strong></em></p>
<h5 id="2-2-selectImports-—-getAutoConfigurationEntry（）"><a href="#2-2-selectImports-—-getAutoConfigurationEntry（）" class="headerlink" title="2.2 selectImports —-&gt;getAutoConfigurationEntry（）"></a>2.2 selectImports —-&gt;getAutoConfigurationEntry（）</h5><p>核心就是getCandidateConfigurations（）函数，里面调用了SpringFactoriesLoader.loadFactoryNames()方法</p>
<p>获取了EnableAutoConfiguration作为key的所有类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata,</span></span><br><span class="line"><span class="params">			AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			<span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 获取EnableAutoConfiguration的属性，从spring.factories中获取所有对应的类</span></span><br><span class="line">		<span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">		List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">// 下面就是把不满足exclude和condition这些条件的删了</span></span><br><span class="line">		configurations = removeDuplicates(configurations);</span><br><span class="line">		Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">		checkExcludedClasses(configurations, exclusions);</span><br><span class="line">		configurations.removeAll(exclusions);</span><br><span class="line">		configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">		fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">  <span class="comment">// 调用SpringFactoriesLoader</span></span><br><span class="line">		List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">				getBeanClassLoader());</span><br><span class="line">   。。。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-getAutoConfigurationEntry-–-SpringFactoriesLoader-loadFactoryNames"><a href="#2-3-getAutoConfigurationEntry-–-SpringFactoriesLoader-loadFactoryNames" class="headerlink" title="2.3 getAutoConfigurationEntry() –&gt; SpringFactoriesLoader.loadFactoryNames()"></a>2.3 getAutoConfigurationEntry() –&gt; SpringFactoriesLoader.loadFactoryNames()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// SpringFactoriesLoader.loadFactoryNames核心代码如下</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 通过classLoader：从所有的jar包中找到META-INF/spring.factories文件</span></span><br><span class="line">			Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line">			<span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">        <span class="comment">// url: jar包中spring.factories的文件路径</span></span><br><span class="line">				<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">				<span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">        <span class="comment">// properties：所有&lt;K,V&gt;对</span></span><br><span class="line">				<span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">				<span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">					<span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();</span><br><span class="line">					String[] factoryImplementationNames =</span><br><span class="line">							StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line">					<span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">						result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">								.add(factoryImplementationName.trim());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>





<h2 id="SPI和Springboot自动配置的关系"><a href="#SPI和Springboot自动配置的关系" class="headerlink" title="SPI和Springboot自动配置的关系"></a>SPI和Springboot自动配置的关系</h2><p>系统里的各个模块，往往有不同的实现方案，我们不允许代码里涉及具体的实现类。所以，SPI就是提供了一个机制：为某个接口寻找服务实现。在运行时发现和使用这些接口。</p>
<table>
<thead>
<tr>
<th>Java SPI</th>
<th>SpringFactories</th>
</tr>
</thead>
<tbody><tr>
<td>配置文件：META-INF&#x2F;services&#x2F;全限定接口名<br />内容：全限定类名（一个类名一行）</td>
<td>META-INF&#x2F;spring.factories<br />内容：key1&#x3D;value1,value2,……</td>
</tr>
<tr>
<td>怎么拿实例：ServiceLoader，返回对象实例</td>
<td>怎么拿实例：SpringFactoriesLoader，返回类名</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/31/kaifa/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/10%E5%B0%8F%E6%97%B6Java%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="蔡正海">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="czh的学习小站">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | czh的学习小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/31/kaifa/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/10%E5%B0%8F%E6%97%B6Java%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF%E6%A0%88/" class="post-title-link" itemprop="url">【1开发】【八股】压测</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="如何压测"><a href="#如何压测" class="headerlink" title="如何压测"></a>如何压测</h1><h3 id="RT、TPS、资源利用率"><a href="#RT、TPS、资源利用率" class="headerlink" title="RT、TPS、资源利用率"></a>RT、TPS、资源利用率</h3><p>影响因素：</p>
<ul>
<li>数据库读写、网络IO、逻辑计算复杂度、缓存</li>
<li>JVM</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240717134417860.png" alt="image-20240717134417860"></p>
<p>三个区，在轻度负载区，RT基本不变，在重度负载区</p>
<h3 id="一个简单的JMeter例子"><a href="#一个简单的JMeter例子" class="headerlink" title="一个简单的JMeter例子"></a>一个简单的JMeter例子</h3><ol>
<li><p>线程组配置</p>
<ol>
<li>线程数：发送http请求的线程数量（50）</li>
<li>循环次数：循环执行多少次操作（2000）</li>
<li>ramp-up：预热时间，要在多久内，创建线程</li>
</ol>
</li>
<li><p>curl导入http请求</p>
</li>
<li><p>设置断言</p>
<ol>
<li>响应断言：code包含0000</li>
<li>断言持续时间：3s</li>
</ol>
</li>
<li><p>报告</p>
<ol>
<li>聚合报告（响应时间，吞吐量，KB）</li>
<li>RT、TPS（插件）</li>
<li>cpu、内存（perform插件）</li>
</ol>
</li>
</ol>
<h3 id="性能关键指标"><a href="#性能关键指标" class="headerlink" title="性能关键指标"></a>性能关键指标</h3><p>TPS、QPS、RT这些就不说，TPS和QPS越大越好，RT响应时间越好越好。</p>
<p>硬件指标，带宽，CPU平均负载(top)。</p>
<h3 id="TPS上限是多少"><a href="#TPS上限是多少" class="headerlink" title="TPS上限是多少"></a>TPS上限是多少</h3><p>和RT，服务端的线程数有关；当然还有带宽</p>
<h2 id="梯度压测"><a href="#梯度压测" class="headerlink" title="梯度压测"></a>梯度压测</h2><p><strong>一点一点压力提上去，分析性能瓶颈</strong></p>
<h2 id="重点1-低延时的接口压测（查询奖品列表）"><a href="#重点1-低延时的接口压测（查询奖品列表）" class="headerlink" title="**重点1  低延时的接口压测（查询奖品列表）"></a>**重点1  低延时的接口压测（查询奖品列表）</h2><p><strong>配置情况</strong></p>
<ul>
<li><p>线程梯度:5、10、15、20、25、30、35、40个线程；循环请求次数5000次</p>
</li>
<li><p>配置断言:超过3s，响应状态码不为1000，则为无效请求</p>
</li>
</ul>
<p><strong>测试结果TPS</strong></p>
<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240718222919726.png" alt="image-20240718222919726"></p>
<p><strong>测试结果RT</strong></p>
<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240718222953489.png" alt="image-20240718222953489"></p>
<p><strong>测试结果CPU负载</strong></p>
<img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240718223749894.png" alt="image-20240718223749894" style="zoom: 33%;" />

<p><strong>结论</strong></p>
<p>随着压力的上升，<strong>TPS不再增加</strong>，响应时间逐渐在增加，偶尔发生异常。但是<strong>CPU负载不高</strong>，说明<strong>瓶颈在带宽</strong>上。</p>
<p><strong>优化方案</strong></p>
<ul>
<li>方案01 – 降低数据包大小</li>
<li>方案02 – 提升带宽，在内网压测</li>
</ul>
<h2 id="重点2-高延时的接口压测（积分兑换-抽奖）"><a href="#重点2-高延时的接口压测（积分兑换-抽奖）" class="headerlink" title="**重点2 高延时的接口压测（积分兑换&#x2F;抽奖）"></a>**重点2 高延时的接口压测（积分兑换&#x2F;抽奖）</h2><ul>
<li><p>线程梯度:100、200、300、400、500、600、700、800个线程; </p>
</li>
<li><p>（为什么线程数要设置的多呢，因为要让TPS上去）</p>
</li>
<li><p>循环请求次数200次</p>
</li>
</ul>
<p><strong>测试结果RT</strong></p>
<p>基本在120</p>
<p>**测试结果CPU负载 **</p>
<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240719172051966.png" alt="image-20240719172051966"></p>
<p><strong>结论</strong></p>
<p>在<strong>高延时</strong>场景下，服务瓶颈主要在<strong>容器最大并发线程数</strong>，卡在容器端</p>
<p>且异常率较高，与阻塞式IO模型有关系</p>
<h2 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h2><ul>
<li>tomcat线程数</li>
<li>数据库连接池：HikariCP</li>
<li>mysql最大连接数</li>
<li>JVM</li>
<li>线程池</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/31/kaifa/bagu/%E6%89%8B%E6%92%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="蔡正海">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="czh的学习小站">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | czh的学习小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/31/kaifa/bagu/%E6%89%8B%E6%92%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98/" class="post-title-link" itemprop="url">【1开发】【八股】手撕多线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="以下面几道经典题为例，如何快速解决手撕多线程题目"><a href="#以下面几道经典题为例，如何快速解决手撕多线程题目" class="headerlink" title="以下面几道经典题为例，如何快速解决手撕多线程题目"></a>以下面几道经典题为例，如何快速解决手撕多线程题目</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://javakeeper.starfish.ink/java/JUC/%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E9%97%AE%E9%A2%98.html#%E4%BD%BF%E7%94%A8-lock">https://javakeeper.starfish.ink/java/JUC/%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E9%97%AE%E9%A2%98.html#%E4%BD%BF%E7%94%A8-lock</a></p>
</blockquote>
<ol>
<li>三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC….”的字符串</li>
<li>两个线程交替打印 0~100 的奇偶数</li>
<li>通过 N 个线程顺序循环打印从 0 至 100</li>
<li>多线程按顺序调用，A-&gt;B-&gt;C，AA 打印 5 次，BB 打印10 次，CC 打印 15 次，重复 10 次</li>
<li>用两个线程，一个输出字母，一个输出数字，交替输出 1A2B3C4D…26Z</li>
</ol>
<h3 id="Lock（题目1）"><a href="#Lock（题目1）" class="headerlink" title="Lock（题目1）"></a>Lock（题目1）</h3><p>三个线程循环打印，怎么打印呢？</p>
<p>三个线程都去抢锁</p>
<ul>
<li>当然只有轮到你了你才能打印</li>
<li>不然的话什么都不干就把锁释放了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Print_N_ABC_lock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> myState,String toPrint)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;times)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span>(state%<span class="number">3</span>==myState)&#123;</span><br><span class="line">                state++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(toPrint);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Print_N_ABC_lock</span> <span class="variable">printNAbcLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Print_N_ABC_lock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            printNAbcLock.print(<span class="number">0</span>,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            printNAbcLock.print(<span class="number">1</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            printNAbcLock.print(<span class="number">2</span>,<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Wait-Notify-题目1"><a href="#Wait-Notify-题目1" class="headerlink" title="Wait&#x2F;Notify(题目1)"></a>Wait&#x2F;Notify(题目1)</h3><p>万精油解法。</p>
<blockquote>
<p>稍微总结一下：</p>
<ul>
<li>加入是只有两个线程，那么直接通知，然后wait就完事</li>
<li>如果是三个线程以上，那么得写个while循环在里面待着</li>
</ul>
</blockquote>
<p>用sychronized。没轮到你就一直在while循环里等着（当然你得wait()，释放锁）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Print_N_ABC_WaitAndNotify</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> myState,String toPrint)</span>  &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;times;i++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (state % <span class="number">3</span> != myState) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                state++;</span><br><span class="line">                System.out.println(toPrint);</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Print_N_ABC_WaitAndNotify</span> <span class="variable">printNAbcLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Print_N_ABC_WaitAndNotify</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            printNAbcLock.print(<span class="number">0</span>,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            printNAbcLock.print(<span class="number">1</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            printNAbcLock.print(<span class="number">2</span>,<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Wait-Notify-题目2"><a href="#Wait-Notify-题目2" class="headerlink" title="Wait&#x2F;Notify(题目2)"></a>Wait&#x2F;Notify(题目2)</h3><p>同样的，synchronized+wait&#x2F;notify。只是这里只有两个线程，连判断条件都不用了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Print_Ji_OU_WaitAndNotify</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>  <span class="variable">size</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;=size)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                    count++;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//防止有子线程被阻塞未被唤醒，导致主线程不退出</span></span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Print_Ji_OU_WaitAndNotify</span> <span class="variable">printJiOuWaitAndNotify</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Print_Ji_OU_WaitAndNotify</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;printJiOuWaitAndNotify.print();&#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;printJiOuWaitAndNotify.print();&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Wait-Notify-题目5"><a href="#Wait-Notify-题目5" class="headerlink" title="Wait&#x2F;Notify(题目5)"></a>Wait&#x2F;Notify(题目5)</h3><p>和题目二一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Print_A1B2C3_WaitAndNotify &#123;</span><br><span class="line">    private int num = 1;</span><br><span class="line">    private char c = &#x27;A&#x27;;</span><br><span class="line">    private final static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    public void print(boolean flag)&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">            for(int i=0;i&lt;26;i++)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if(flag==false) &#123;</span><br><span class="line">                        System.out.println(num+i);</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        System.out.println((char)(c+i));</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Print_A1B2C3_WaitAndNotify printA1B2C3WaitAndNotify = new Print_A1B2C3_WaitAndNotify();</span><br><span class="line">        new Thread(()-&gt;&#123;printA1B2C3WaitAndNotify.print(false);&#125;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;printA1B2C3WaitAndNotify.print(true);&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/31/kaifa/mianjing/mianjing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="蔡正海">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="czh的学习小站">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | czh的学习小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/31/kaifa/mianjing/mianjing/" class="post-title-link" itemprop="url">【1开发】【八股】面经</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>组合模式规则树（单例）</p>
<p>公众号重试</p>
<h2 id="用到了什么设计模式"><a href="#用到了什么设计模式" class="headerlink" title="用到了什么设计模式"></a>用到了什么设计模式</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/cccccc96/Interview/tree/main/Design%20Pattern">https://github.com/cccccc96/Interview/tree/main/Design%20Pattern</a></p>
</blockquote>
<p>在抽奖的规则过滤中，用到了责任链和组合模式。最核心的作用就是把if else进行拆分，便于后期维护。</p>
<p>对于不同的抽奖策略采用了策略模式。</p>
<p>对于流程开发，采用了模版模式</p>
<h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><p>故名思义，责任链就是一个链表，唯一的区别就是我们为每个节点做一个实现（因为每个节点要实现不同的功能）。</p>
<p>所以我们执行责任链就是遍历这个链表，每个节点可能会拦截掉，或是继续下一个节点。</p>
<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240706161127811.png" alt="image-20240706161127811"></p>
<h3 id="组合模式-规则树模型"><a href="#组合模式-规则树模型" class="headerlink" title="组合模式-规则树模型"></a>组合模式-规则树模型</h3><p>故名思义，规则树模型就是一个树形结构。可以想象一个B+树，根据大小进行遍历。那么，规则树也是类似，只是每个树节点有不同的规则。</p>
<ul>
<li>Filter（树节点）：拿不同种类的信息（年龄信息&#x2F;性别信息）<ul>
<li>filter(): 遍历所有子边，哪个边符合，则找到对应的下一个子节点</li>
</ul>
</li>
<li>IEngine：遍历整颗树<ul>
<li>可以想象，搜索树中，小于进左子树，大于进右子树；而在规则树中，每条边的规则是固定的</li>
</ul>
</li>
<li>好处：方便维护，可以把树结构存进数据库中</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240706175427996.png" alt="image-20240706175427996"></p>
<h3 id="策略模式和模版模式"><a href="#策略模式和模版模式" class="headerlink" title="策略模式和模版模式"></a>策略模式和模版模式</h3><p>这两个非常简单</p>
<ul>
<li>策略模式：一个接口，多个实现，需要哪个策略用哪个</li>
<li>模版模式：定义抽象类，定义流程，每个步骤都是一个抽奖方法。步骤具体的实现去继承类里面去做。</li>
</ul>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>功能：拆分出了核心流程与辅助流程</p>
<p>实现也非常简单，只需要做两件事</p>
<ul>
<li>定义各种listener，方法里去做要做的事</li>
<li>定义一个Manager，负责注册和通知</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240706214913020.png" alt="image-20240706214913020"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/31/kaifa/mianjing/%E8%87%AA%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="蔡正海">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="czh的学习小站">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | czh的学习小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/31/kaifa/mianjing/%E8%87%AA%E6%B5%8B/" class="post-title-link" itemprop="url">【1开发】【八股】面经自测</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="整理答题思路"><a href="#整理答题思路" class="headerlink" title="整理答题思路"></a>整理答题思路</h1><blockquote>
<p>这里暂时只放最最基本的面试题，汇总在这里，面试前看看，别最基础的也忘了。</p>
<p>Java，并发，Mysql，Redis，消息队列（Kafka）、网络</p>
</blockquote>
<h3 id="Java-中的集合类型？哪些是线程安全的？"><a href="#Java-中的集合类型？哪些是线程安全的？" class="headerlink" title="Java 中的集合类型？哪些是线程安全的？"></a>Java 中的集合类型？哪些是线程安全的？</h3><p>List、Set、Map</p>
<p>ConcurrentHashMap线程安全</p>
<h3 id="hashmap-的底层实现原理、put-方法实现流程、扩容机制？和Redis区别"><a href="#hashmap-的底层实现原理、put-方法实现流程、扩容机制？和Redis区别" class="headerlink" title="hashmap 的底层实现原理、put()方法实现流程、扩容机制？和Redis区别"></a>hashmap 的底层实现原理、put()方法实现流程、扩容机制？和Redis区别</h3><p>底层实现原理就不赘述了，关键词记一下，别忘了</p>
<ul>
<li><p><strong>结构：</strong></p>
<ul>
<li>桶数组，链表、红黑树</li>
<li>hashcode()高16位和低16位异或，</li>
</ul>
</li>
<li><p><strong>put：</strong></p>
<ul>
<li>覆盖？链表尾差&#x2F;红黑树？（是否需要树话，是否需要扩容）</li>
</ul>
</li>
<li><p><strong>扩容：</strong></p>
<ul>
<li>2^n次方，0.75，8，64</li>
</ul>
</li>
</ul>
<p>和Redis区别，<strong>一个分布式，一个单机</strong></p>
<h3 id="HashMap-为什么不安全，ConcurrentHashMap"><a href="#HashMap-为什么不安全，ConcurrentHashMap" class="headerlink" title="HashMap 为什么不安全，ConcurrentHashMap"></a>HashMap 为什么不安全，ConcurrentHashMap</h3><p>当然不安全</p>
<ul>
<li>两个<strong>同时put</strong>，应该用链表的，会被覆盖</li>
<li><strong>get和put</strong>同时，这时候rehash了，就get null了</li>
</ul>
<p>ConcurrentHashMap原理（<strong>synchronized</strong>锁桶数组上的节点）（<strong>自旋+CAS</strong>避免不必要的锁）</p>
<ul>
<li>CAS+自旋 初始化数组</li>
<li>CAS （散列到的节点是空，CAS写入）</li>
<li>CAS+synchronized （进行扩容）</li>
<li>synchronized（正常写入数据）</li>
</ul>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul>
<li>进程（JVM进程）<ul>
<li>多核CPU，同时刻</li>
</ul>
</li>
<li>线程<ul>
<li>多个子任务通过事件片轮转，不同时刻</li>
<li>Java虚拟机：<ul>
<li>共享资源：堆、方法区</li>
<li>线程：程序计数器、栈</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="线程的生命周期和状态？"><a href="#线程的生命周期和状态？" class="headerlink" title="线程的生命周期和状态？"></a>线程的生命周期和状态？</h3><p><strong>6个状态</strong></p>
<ul>
<li>正常：<ul>
<li>new，run，terminate</li>
</ul>
</li>
<li>wait、sleep、lock</li>
</ul>
<h3 id="sleep-和-wait-的区别"><a href="#sleep-和-wait-的区别" class="headerlink" title="sleep 和 wait 的区别"></a>sleep 和 wait 的区别</h3><p>sleep：线程，不释放锁</p>
<p>wait：对象，释放锁</p>
<h3 id="ThreadLocal与Synchronized区别"><a href="#ThreadLocal与Synchronized区别" class="headerlink" title="ThreadLocal与Synchronized区别"></a>ThreadLocal与Synchronized区别</h3><p>线程副本；加锁</p>
<p>空间换时间；时间换空间</p>
<p>Synchronized失去了并发性。</p>
<h3 id="ThreadLocal-的实现原理？线程安全"><a href="#ThreadLocal-的实现原理？线程安全" class="headerlink" title="ThreadLocal 的实现原理？线程安全"></a>ThreadLocal 的实现原理？线程安全</h3><ul>
<li>ThreadLocalMap：弱引用（ThreadLocal），强引用（局部变量本身）</li>
<li>斐波那契散列，开放定址法，扩容（先清理，再判断是否需要扩容）</li>
<li>线程不安全，弱引用没了，强引用还在。记得remove</li>
</ul>
<h3 id="Java-内存模型（JMM）"><a href="#Java-内存模型（JMM）" class="headerlink" title="Java 内存模型（JMM）"></a>Java 内存模型（JMM）</h3><p>抽象模型，主存与本地内存</p>
<p>并发问题：可见性（volitile），原子性（synchronized），有序性（volitile）</p>
<p>指令重排，happens-before</p>
<h3 id="Volitile"><a href="#Volitile" class="headerlink" title="Volitile"></a>Volitile</h3><p><strong>可见性</strong>：读写屏障</p>
<p><strong>有序性</strong>：禁止指令重排</p>
<h3 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h3><p>代码块，方法，类（原子）</p>
<p>有序性（volatile）</p>
<h3 id="synchronized实现原理？可重入？锁升级？"><a href="#synchronized实现原理？可重入？锁升级？" class="headerlink" title="synchronized实现原理？可重入？锁升级？"></a>synchronized实现原理？可重入？锁升级？</h3><p><strong>实现原理（可重入）</strong></p>
<ul>
<li>ObjectMonitor：CAS获取Owner，_recursions ++（可重入的），_EntryList</li>
</ul>
<p><strong>锁升级</strong></p>
<ul>
<li><p>对象头的Mark Word</p>
</li>
<li><p>无锁，偏向锁（长时间同一线程获取锁），轻量锁（锁在不同时刻，不涉及上下文切换），重量锁（）</p>
</li>
<li><p>流程</p>
<ul>
<li>偏向锁（记下这个线程ID）</li>
<li>—-（CAS修改线程ID失败）—-&gt; 轻量锁</li>
<li>—-（自旋获取锁，避免立即进入阻塞）—–&gt;  重量级锁</li>
</ul>
</li>
</ul>
<h3 id="ReentrantLock和Synchronized区别"><a href="#ReentrantLock和Synchronized区别" class="headerlink" title="ReentrantLock和Synchronized区别"></a>ReentrantLock和Synchronized区别</h3><ul>
<li>公平锁（FIFO）和非公平锁；非公平锁</li>
<li>AQS；底层</li>
</ul>
<h3 id="CAS和ABA"><a href="#CAS和ABA" class="headerlink" title="CAS和ABA"></a>CAS和ABA</h3><p>乐观锁（相比之下synchronized是悲观锁）</p>
<p>A改为B，又改为A，CAS操作线程<strong>无法知晓该位置的值已经被修改过</strong>了（<strong>改进：通过版本号</strong>）</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li><p>好处</p>
<ul>
<li><strong>降低资源消耗</strong>：重复利用已创建的线程</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，防止无限制地创建线程，造成大量的线程上下文切换</li>
</ul>
</li>
<li><p>应用（大营销）</p>
<ul>
<li>项目背景：抽奖是高并发的，需要快速响应用户请求，（聚合查询奖品信息；定时任务更新库存）</li>
<li>核心线程数：cpu核的两倍，即云服务器4核 * 2&#x3D;8（有很多网络通信，数据库操作，所以是IO密集性任务，有较多的空闲线程）</li>
<li>最大线程数：8 * 2 &#x3D;16 </li>
<li>阻塞队列：SynchronousQueue（提交后立即交给等待的线程处理，提高响应速度）</li>
<li>拒绝策略：CallerRunsPolicy（由调用线程来执行该任务，保证了任务能成功执行）</li>
</ul>
</li>
</ul>
<h3 id="线程池工作流程"><a href="#线程池工作流程" class="headerlink" title="线程池工作流程"></a>线程池工作流程</h3><p>核心线程—&gt; 任务队列 —&gt; 核心队列 —&gt;拒绝策略</p>
<ul>
<li>用start：run， start</li>
<li>是否需要返回值：execute，submit</li>
</ul>
<h3 id="线程池CompletableFuture"><a href="#线程池CompletableFuture" class="headerlink" title="线程池CompletableFuture"></a>线程池CompletableFuture</h3><ul>
<li>添加任务：runAsync（参数：runnable，线程池）</li>
<li>编排：thenCombine，thenAccept</li>
<li>等待所有任务执行完毕：allof().join()</li>
</ul>
<h3 id="MySQL存储引擎（Innodb，MyISAM）"><a href="#MySQL存储引擎（Innodb，MyISAM）" class="headerlink" title="MySQL存储引擎（Innodb，MyISAM）"></a>MySQL存储引擎（Innodb，MyISAM）</h3><p>选Innodb（事务，行级锁，redo Log和Undo Log）</p>
<h3 id="三大日志"><a href="#三大日志" class="headerlink" title="三大日志"></a>三大日志</h3><ul>
<li>binlog（用于主从复制）<ul>
<li>索引文件（所有日志文件的顺序），<strong>日志文件</strong>（所有DDL、DML）</li>
</ul>
</li>
<li>redolog<ul>
<li>物理数据页的修改操作</li>
</ul>
</li>
</ul>
<h3 id="更新语句的两阶段提交"><a href="#更新语句的两阶段提交" class="headerlink" title="更新语句的两阶段提交"></a>更新语句的两阶段提交</h3><p>保证两个日志的逻辑一致</p>
<ul>
<li><p>流程</p>
<ul>
<li><p>写入redolog，并将状态修改为prepare</p>
</li>
<li><p>写入binlog</p>
</li>
<li><p>提交事务，并在redo log中设置为commit</p>
</li>
</ul>
</li>
</ul>
<h3 id="MySQL执行一条SQL语句的流程"><a href="#MySQL执行一条SQL语句的流程" class="headerlink" title="MySQL执行一条SQL语句的流程"></a>MySQL执行一条SQL语句的流程</h3><ul>
<li>连接器：开始处理这个请求</li>
<li>解析器：检查语句是否符合SQL语法规则</li>
<li>优化器：索引</li>
<li>执行器：通过具体的存储引擎，进行数据读写</li>
</ul>
<h3 id="定位慢SQL"><a href="#定位慢SQL" class="headerlink" title="定位慢SQL"></a>定位慢SQL</h3><ul>
<li>“SET GLOBAL slow_query_log”；mysqldumpslow去日志文件里找</li>
<li>Explain分析如何执行SQL语句的<ul>
<li>索引问题：possiable_keys（能用到的索引），key（实际用到的索引）</li>
<li>IO开销问题：rows（要遍历的行数），filtered（有效行数&#x2F;扫描行数比值）字段来查看</li>
</ul>
</li>
<li>优化<ul>
<li>避免不必要的列</li>
<li>索引优化<ul>
<li>覆盖索引（最左前缀原则，必须包含最左的）</li>
<li>适当使用前缀索引</li>
<li>避免使用&lt;&gt;</li>
</ul>
</li>
<li>分页优化<ul>
<li>延迟关联（先检索出需要的id）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="MySQL索引有哪些"><a href="#MySQL索引有哪些" class="headerlink" title="MySQL索引有哪些"></a>MySQL索引有哪些</h3><ul>
<li>主键（id），唯一索引（幂等id），普通索引</li>
<li>聚簇索引（主键，直接指向内存地址），非聚簇索引（普通索引，叶子节点存的主键ID，需要回表）</li>
</ul>
<h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><p>相比UUID64位更小，时间戳也有一定的连续性</p>
<p>分布式唯一ID（64位）hutool</p>
<ul>
<li>时间戳（41）</li>
<li>机器表示（workid，datacenter）（10）</li>
<li>自增序列（12）</li>
</ul>
<h3 id="MySQL加索引需要注意些什么"><a href="#MySQL加索引需要注意些什么" class="headerlink" title="MySQL加索引需要注意些什么"></a>MySQL加索引需要注意些什么</h3><ul>
<li>选择合适的列<ul>
<li>经常作为查询条件、排序条件、分组条件的列是建立索引的好候选（where，order by，group by）</li>
<li>频繁更新的不要建立索引</li>
<li>区分度低的（例如性别）</li>
</ul>
</li>
<li>避免过多的索引<ul>
<li>每个索引都需要占用额外的磁盘空间</li>
<li>更新，所有的索引都需要更新</li>
</ul>
</li>
<li>利用前缀索引和索引列的顺序</li>
</ul>
<h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><p>Where里函数，&lt;&gt;，最左匹配，or两边索引不一致</p>
<h3 id="MySQL为什么用B-树"><a href="#MySQL为什么用B-树" class="headerlink" title="MySQL为什么用B+树"></a>MySQL为什么用B+树</h3><ul>
<li>尽量减少读写次数（相比搜索树）</li>
<li>只在叶子节点存数据（相比B树会在每个节点存数据，那么能存的东西就少了）；叶子结点有序链表，范围查询更方便</li>
</ul>
<h3 id="MySQL有哪些锁"><a href="#MySQL有哪些锁" class="headerlink" title="MySQL有哪些锁"></a>MySQL有哪些锁</h3><ul>
<li>读写锁<ul>
<li>读锁：for share mode（读锁是能获取的）</li>
<li>写锁：for update mode（读写锁都不能获取）</li>
</ul>
</li>
<li>行锁，表锁<ul>
<li>行锁：记录锁，间隙锁、临键锁（用来坚决欢度）</li>
<li>表锁：意向锁</li>
</ul>
</li>
<li>乐观锁、悲观锁<ul>
<li>乐观锁：MVCC（冲突提交才检查）</li>
<li>悲观锁：for update</li>
</ul>
</li>
</ul>
<h3 id="MySQL事务的四个特性"><a href="#MySQL事务的四个特性" class="headerlink" title="MySQL事务的四个特性"></a>MySQL事务的四个特性</h3><ul>
<li><p>A（undo log）</p>
</li>
<li><p>D（redo log）</p>
</li>
<li><p>I（MVCC）</p>
</li>
<li><p>C</p>
</li>
</ul>
<h3 id="MySQL事务的隔离级别"><a href="#MySQL事务的隔离级别" class="headerlink" title="MySQL事务的隔离级别"></a>MySQL事务的隔离级别</h3><p>脏读（读取未提交的数据），不可重复读（另一个事务修改了值并提交，两次相同查询结果不同），幻读（另一个事务插入，发现多了一条数据）。</p>
<p>读未提交，读已提交（MVCC，每次读取生成一个readview），可重复读（MVCC，第一次读取的时候生成一个readview），串行化（加锁）。</p>
<h3 id="MySQL事务中MVCC的实现"><a href="#MySQL事务中MVCC的实现" class="headerlink" title="MySQL事务中MVCC的实现"></a>MySQL事务中MVCC的实现</h3><ul>
<li>版本链<ul>
<li>隐藏列：创建该版本的事务ID，undo指针</li>
</ul>
</li>
<li>ReadView<ul>
<li>作用：确定哪些版本的行记录是可见的</li>
<li>四个属性：创建该ReadView的事务id，活跃id列表，最小事务id，最大事务id</li>
<li>下面的情况是可见（也就是已经提交了）：比最小事务id小；在最小事务id和最大事务id之间且不在活跃id中</li>
</ul>
</li>
</ul>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>单表单库数据量过大，连接数量过大，导致性能下降，做的一个负载均衡。</p>
<p><strong>水平分库分表</strong>（用户信息，发奖订单，积分订单，活动订单），垂直分库分表</p>
<h3 id="不停机扩容"><a href="#不停机扩容" class="headerlink" title="不停机扩容"></a>不停机扩容</h3><ol>
<li>在线双写，查询走旧库（进行数据的同步和校验）</li>
<li>在线双写，查询走新库</li>
<li>过一段时间，确定没有请求之后，就可以下线老库</li>
</ol>
<h3 id="Redis用来干嘛"><a href="#Redis用来干嘛" class="headerlink" title="Redis用来干嘛"></a>Redis用来干嘛</h3><ul>
<li>缓存<ul>
<li>String：各种东西，比如奖品，验证码</li>
<li>Hash：getMap，奖品概率查找表</li>
<li>List：所有的线程池信息</li>
</ul>
</li>
<li>阻塞队列+延时队列<ul>
<li>库存趋势更新到mysql，不稳定</li>
<li>阻塞队列（RBlockingQueue）：线程安全，在队列满或空时阻塞线程</li>
<li>延时队列（RDelayedQueue）：在一个延迟时间后，才会被放入RBlockingQueue</li>
</ul>
</li>
<li>分布式锁<ul>
<li>库存扣减，防止超卖</li>
</ul>
</li>
<li>发布，订阅<ul>
<li>线程池修改</li>
<li>发布：redissonClient.getTopic.pulish</li>
<li>订阅：redissonClient.getTopic.addListener</li>
</ul>
</li>
</ul>
<h3 id="阻塞队列和延时队列的实现"><a href="#阻塞队列和延时队列的实现" class="headerlink" title="阻塞队列和延时队列的实现"></a>阻塞队列和延时队列的实现</h3><p>阻塞队列：lpush，brpop（阻塞）</p>
<p>延时队列：zset，定期从zset中获取指定时间戳的</p>
<h3 id="Redis中的常用命令"><a href="#Redis中的常用命令" class="headerlink" title="Redis中的常用命令"></a>Redis中的常用命令</h3><ul>
<li>基本操作：set，get，decr</li>
<li>分布式锁：SetIfAbsent，tryLock</li>
<li>发布订阅：pulish，addListener</li>
<li>获取Hash或List：getMap，getblockingqueue，getDelayedQueue</li>
<li>其他：isExists，getLock</li>
</ul>
<h3 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h3><ul>
<li>基于内存的数据存储</li>
<li>单线程模型：避免了线程切换和锁竞争</li>
<li>IO多路复用<ul>
<li>select&#x2F;epoll机制，保证了单个线程能处理多个IO读写</li>
<li>将socket句柄注册进epoll，然后epoll帮你监听哪些socket上有消息到达</li>
<li>相比于read请求一直阻塞；只有epoll调用才会阻塞，收发客户消息是不会阻塞的</li>
</ul>
</li>
<li>高效的数据结构</li>
</ul>
<h3 id="Redis-的持久化方式？RDB-和-AOF-的区别？Redis-宕机哪种恢复的比较快？"><a href="#Redis-的持久化方式？RDB-和-AOF-的区别？Redis-宕机哪种恢复的比较快？" class="headerlink" title="Redis 的持久化方式？RDB 和 AOF 的区别？Redis 宕机哪种恢复的比较快？"></a>Redis 的持久化方式？RDB 和 AOF 的区别？Redis 宕机哪种恢复的比较快？</h3><p><strong>两个持久化方式</strong></p>
<ul>
<li>RDB（Redis DataBase）：异步创建数据集的快照，不会阻塞<ul>
<li>bgsava</li>
<li>redis.conf中配置命令，发生多少次变更，多少秒后触发一次RDB</li>
</ul>
</li>
<li>AOF（Append only file）：追加每个写操作到AOF文件中<ul>
<li>流程1:将所有写命令追加到AOF buffer中</li>
<li>流程2:持久化sync<ul>
<li>每条写指令&#x2F;每秒&#x2F;只在Redis关闭时执行</li>
</ul>
</li>
<li>流程3:重写<ul>
<li>直接将Redis重写成一系列写命令</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>两者区别</strong></p>
<p>RDB，文件小，对性能影响较小，但是容易造成数据丢失（性能是首要指标）</p>
<p>AOF，文件大，实时性好，对性能影响较大（尽可能减少数据丢失）</p>
<p>混合持久化：在AOF重写的同时，生成一份RDB快照，这份快照作为AOF文件的一部分，最后再附加新的写入命令。</p>
<h3 id="什么是缓存击穿、缓存穿透、缓存雪崩"><a href="#什么是缓存击穿、缓存穿透、缓存雪崩" class="headerlink" title="什么是缓存击穿、缓存穿透、缓存雪崩"></a>什么是缓存击穿、缓存穿透、缓存雪崩</h3><p><strong>缓存击穿</strong></p>
<p>热点数据在过期的那一刻，直达数据库。</p>
<p>解决方案</p>
<ul>
<li><p>发现缓存中没有，对A这个数据加锁，拿到缓存再返回给用户</p>
</li>
<li><p>不断刷新过期时间</p>
</li>
</ul>
<p><strong>缓存穿透</strong></p>
<p>查询根本不存在的数据，那么也会直达数据库</p>
<p>解决方案</p>
<ul>
<li>哪怕不存在的数据，也缓存空值（适用数据缺失较少场景，有数据不一致的风险）<ul>
<li>需要设置较短的过期时间</li>
</ul>
</li>
<li>加一个布隆过滤器（适用海量数据的场景）<ul>
<li>告诉我们key一定不存在或者可能存在</li>
<li>也就是多个hash映射，只要有一个为0，就说明不存在</li>
</ul>
</li>
</ul>
<p><strong>缓存雪崩</strong></p>
<p>缓存大量过期，或者缓存服务器宕机</p>
<p>解决方案</p>
<ul>
<li>集群部署</li>
<li>使用多级缓存（Redis不可用了，也可以用本地缓存）</li>
<li>设置不同的过期时间</li>
</ul>
<h3 id="如何保证数据的一致性"><a href="#如何保证数据的一致性" class="headerlink" title="如何保证数据的一致性"></a>如何保证数据的一致性</h3><p> 先写MySQL，再删除Redis。只会有一次不一致的情况，对于不是强一致性的业务，可以容忍。</p>
<ul>
<li>为什么删除缓存：删除缓存比更新缓存快的多</li>
<li>为什么先更数据库：MySQL的IO慢的多，容易在Redis中产生脏数据</li>
</ul>
<p>假如对一致性要求很高呢（缓存删除失败，并发导致写入了脏数据）</p>
<ul>
<li>引入消息队列保证缓存被删除</li>
<li>设置缓存过期时间兜底</li>
</ul>
<h3 id="怎么处理Redis中的热Key和大Key"><a href="#怎么处理Redis中的热Key和大Key" class="headerlink" title="怎么处理Redis中的热Key和大Key"></a>怎么处理Redis中的热Key和大Key</h3><p>QPS集中在特定的Key，那么就是热Key。</p>
<p>如何处理</p>
<ul>
<li>把Key打到不同的Redis实例</li>
<li>二级缓存</li>
</ul>
<h3 id="Redis主从复制，哨兵，集群"><a href="#Redis主从复制，哨兵，集群" class="headerlink" title="Redis主从复制，哨兵，集群"></a>Redis主从复制，哨兵，集群</h3><p>高可用：主从复制（手动切换），哨兵（自动切换，哨兵节点，选举一个负责故障转移）</p>
<p>数据分区：集群（哈希槽，keys映射到实例）</p>
<h3 id="消息队列的三个好处"><a href="#消息队列的三个好处" class="headerlink" title="消息队列的三个好处"></a>消息队列的三个好处</h3><p><strong>异步处理，减少响应时间（以发奖为例）</strong></p>
<p>请求在写入消息队列就立即返回给用户了</p>
<p><strong>削峰，限流（以发奖为例）</strong></p>
<p>把要做的事务存储在消息队列中（压力转嫁到MQ），然后后端再慢慢根据自己的能力去消费这些消息，避免直接把后端服务打掉。</p>
<p><strong>解耦</strong></p>
<p>新增业务，只要对该类消息感兴趣，只需订阅该消息</p>
<h3 id="为什么选择Kafka（send，KafkaListener）"><a href="#为什么选择Kafka（send，KafkaListener）" class="headerlink" title="为什么选择Kafka（send，KafkaListener）"></a>为什么选择Kafka（send，KafkaListener）</h3><p>极致的性能，超高吞吐量（百万级）；可以实现高可用，可以做到0消息丢失的情况；生态系统的兼容性非常好</p>
<p>缺点，<strong>消息重复消费</strong>，造成轻微的影响。</p>
<h3 id="保证Kafka的消费顺序"><a href="#保证Kafka的消费顺序" class="headerlink" title="保证Kafka的消费顺序"></a>保证Kafka的消费顺序</h3><p>Kafka一个topic里包含多个partition，只保证partition分区中的消息有序。所以send的时候指定分区（或者使用对象id作为key）。</p>
<h3 id="保证Kafka的消息不丢失"><a href="#保证Kafka的消息不丢失" class="headerlink" title="保证Kafka的消息不丢失"></a>保证Kafka的消息不丢失</h3><p><strong>生产者丢失消息</strong></p>
<ol>
<li>send函数的返回值是ListenableFuture，添加回调函数，判定消息结果。</li>
<li>设置重试次数稍微大一点</li>
<li>将消息发送之前，写入task表，如果发送失败，定时任务去补偿。</li>
</ol>
<p><strong>消费者丢失消息</strong></p>
<p>偏移量，当消费者自动提交了偏移量，但是还没消费就挂掉了。改成手动提交偏移量。</p>
<p><strong>Kafka丢失消息</strong></p>
<p>Kafka挂掉，多副本机制，但消息还没有同步。</p>
<p>使用acks&#x3D;all，最安全的，但是延迟会很高</p>
<h3 id="Kafka如何保证消息不重复消费"><a href="#Kafka如何保证消息不重复消费" class="headerlink" title="Kafka如何保证消息不重复消费"></a>Kafka如何保证消息不重复消费</h3><ul>
<li>mysql幂等校验</li>
<li>最根本的原因，已经消费的数据没有成功提交offset，拉取到消息再提交</li>
</ul>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>应用层：HTTP、DNS（应用把应用数据传给下一层）</p>
<p>传输层：TCP、UDP</p>
<p>网络层：MAC</p>
<p>网络接口层</p>
<h3 id="输入HTTP流程"><a href="#输入HTTP流程" class="headerlink" title="输入HTTP流程"></a>输入HTTP流程</h3><ol>
<li>HTTP get&#x2F;post</li>
<li>DNS查询IP地址（根，顶级，权威）</li>
<li>TCP三次握手</li>
<li>ARP，获取MAC地址（广播，ARP缓存）</li>
</ol>
<h3 id="说说DNS的解析过程"><a href="#说说DNS的解析过程" class="headerlink" title="说说DNS的解析过程"></a>说说DNS的解析过程</h3><p>查看本地服务器的缓存，不然就走根服务器、顶级服务器、权限域名</p>
<h3 id="HTTP1-0-1-1-2-0-3-0"><a href="#HTTP1-0-1-1-2-0-3-0" class="headerlink" title="HTTP1.0  1.1  2.0 3.0"></a>HTTP1.0  1.1  2.0 3.0</h3><p>短链接，长链接，多路复用，快速UDP链接</p>
<h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p>加了SSL&#x2F;TLS协议（非对称加密）</p>
<ul>
<li>非对称加密：服务端向客户端发送数字证书公钥，生成会话密钥</li>
<li>双方用会话密钥加密通话内容</li>
</ul>
<h3 id="TCP三次握手，四次挥手"><a href="#TCP三次握手，四次挥手" class="headerlink" title="TCP三次握手，四次挥手"></a>TCP三次握手，四次挥手</h3><p>SYN（Synchronize，连接请求），seq（序列号），ack（应答）</p>
<p>FIN（finish请求），多了一次等待数据完成，2MSL</p>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>线程：栈帧（局部变量，返回）</p>
<p>堆：类，字符串常量</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/31/kaifa/mianjing/%E8%87%AA%E6%B5%8B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="蔡正海">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="czh的学习小站">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | czh的学习小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/31/kaifa/mianjing/%E8%87%AA%E6%B5%8B2/" class="post-title-link" itemprop="url">【1开发】【八股】面经自测2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>这里暂时只放最最基本的面试题，汇总在这里，面试前看看，别最基础的也忘了。</p>
<p>Java，并发，Mysql，Redis，消息队列（Kafka）、网络</p>
</blockquote>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="八种数据类型"><a href="#八种数据类型" class="headerlink" title="八种数据类型"></a>八种数据类型</h2><p>数：byte、short、int、long、float、double</p>
<p>字符：char</p>
<p>布尔：boolean</p>
<h2 id="自动拆箱-装箱"><a href="#自动拆箱-装箱" class="headerlink" title="自动拆箱&#x2F;装箱"></a>自动拆箱&#x2F;装箱</h2><p>装箱：将基本数据类型转换为包装类型（Integer.valueOf()）</p>
<p>拆箱：将包装类型转换为基本数据类型（i.intValue()）</p>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><p>封装（将数据和行为捆绑在一起形成一个对象）、继承（extends，子类继承父类）、多态（重写）</p>
<p>为什么Java里应该多组合少继承：因为继承是强耦合的，违背了开闭原则（不修改代码，而是添加新的代码）。组合模式更灵活</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>修饰类：不能被继承</p>
<p>修饰方法：不能被重写</p>
<p>修饰变量：不能被修改</p>
<h2 id="String、StringBuilder、StringBuffer"><a href="#String、StringBuilder、StringBuffer" class="headerlink" title="String、StringBuilder、StringBuffer"></a>String、StringBuilder、StringBuffer</h2><p>String：会生成一个新的String对象</p>
<p>StringBuilder：非线程安全</p>
<p>StringBuffer：线程安全</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Error：OOM；stack</p>
<p>Exception：IOException；空指针；数组越界；类型转换</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>想在运行时获取类的信息，调用类的方法。</p>
<p>动态代理：通过反射创建代理类，method调用方法</p>
<p>field：修改私有字段</p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>系统里的各个模块，往往有不同的实现方案，我们不允许代码里涉及具体的实现类。所以，SPI就是提供了一个机制：为某个接口寻找服务实现。在运行时发现和使用这些接口。</p>
<table>
<thead>
<tr>
<th>Java SPI</th>
<th>SpringFactories</th>
</tr>
</thead>
<tbody><tr>
<td>配置文件：META-INF&#x2F;services&#x2F;全限定接口名<br />内容：全限定类名（一个类名一行）</td>
<td>META-INF&#x2F;spring.factories<br />内容：key1&#x3D;value1,value2,……</td>
</tr>
<tr>
<td>怎么拿实例：ServiceLoader，返回对象实例</td>
<td>怎么拿实例：SpringFactoriesLoader，返回类名</td>
</tr>
</tbody></table>
<h2 id="BIO-NIO"><a href="#BIO-NIO" class="headerlink" title="BIO&#x2F;NIO"></a>BIO&#x2F;NIO</h2><p>用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong>来间接访问内核空间</p>
<h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>IO会阻塞当前线程，直到操作完成。所以需要一个线程一个IO。</p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>IO多路复用，单线程维护所有IO</p>
<ul>
<li>Java NIO<ul>
<li>buffer：缓冲区存储数据</li>
<li>Channel：FileChannel&#x2F;SocketChannel，负责从文件&#x2F;网络中向buffer传输数据</li>
<li>Selector：轮询注册在上面的Channel，是否有新的读写事件，加入就绪集合<ul>
<li>epoll：事件驱动，当某个socket有事件发生时，通过回调函数将其加入<ul>
<li>边缘触发：只苏醒一次，需要保证一次性读完</li>
<li>水平触发：不断苏醒，直到缓冲区都读完</li>
<li>零拷贝：减少用户空间和内核空间之间进行多次拷贝</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="四层模型"><a href="#四层模型" class="headerlink" title="四层模型"></a>四层模型</h2><p>应用层（DNS）</p>
<p>传输层（TCP）</p>
<p>网络层（ARP）</p>
<p>网络接口层（以太网、WIFI）</p>
<h2 id="从浏览器地址输入url到显示网页的过程"><a href="#从浏览器地址输入url到显示网页的过程" class="headerlink" title="从浏览器地址输入url到显示网页的过程"></a>从浏览器地址输入url到显示网页的过程</h2><p>DNS解析：DNS查询IP地址（根、顶级域、权威域）</p>
<p>TCP连接：建立TCP连接（三次握手）</p>
<p>开始发送HTTP请求：浏览器发送HTTP请求报文，服务器处理后返回HTTP响应报文，浏览器解析里面的HTLM文件并渲染。</p>
<p>TCP连接关闭：（四次挥手）</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>200: 请求成功</p>
<p>3xx: 重定向（301永久，302临时）</p>
<p>4xx：请求错误（400语法错误、401未认证）</p>
<p>500：服务器内部错误</p>
<h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><p>SSL&#x2F;TLS协议，是非对称加密的（服务端向客户端发送数字证书公钥，生成会话密钥，用密钥通信）。我们需要先向CA申请证书。</p>
<p>端口号80&#x2F;443</p>
<h2 id="HTTP1-0-1-1-2-0-3-0"><a href="#HTTP1-0-1-1-2-0-3-0" class="headerlink" title="HTTP1.0  1.1  2.0 3.0"></a>HTTP1.0  1.1  2.0 3.0</h2><p>短链接，长链接，多路复用，快速UDP链接</p>
<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>请求行：get&#x2F;post；url</p>
<p>请求头：主机名；类型；浏览器类型</p>
<p>消息正文：post请求里的表单数据</p>
<h2 id="粘包和拆包"><a href="#粘包和拆包" class="headerlink" title="粘包和拆包"></a>粘包和拆包</h2><p>TCP是面向流的，它并不包含数据包的概念。一个完整的包可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送。</p>
<p>解决方案：发送端将每个包都封装成固定的长度，不足之处可以补0</p>
<h2 id="TCP三次握手，四次挥手"><a href="#TCP三次握手，四次挥手" class="headerlink" title="TCP三次握手，四次挥手"></a>TCP三次握手，四次挥手</h2><p>SYN（Synchronize，连接请求），seq（序列号），ack（应答）【SYN，SYN+ACK，ACK】</p>
<p>（状态：close，syn_sent，establish；close，listen，syn_rcvd，establish）</p>
<p>FIN（finish请求），多了一次等待数据完成，2MSL【FIN，ACK，FIN+ACK，ACK】</p>
<ul>
<li>为什么是2MSL：如果最后一个ACK，服务端重传</li>
</ul>
<p>（状态：establish，fin_wait1，fin_wait2, time_wait,close；establish，close_wait，last_ack，close）</p>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>本机维护一个ARP缓存，保存IP到MAC的地址。</p>
<p>如果缓存中没有，向网络中广播一个ARP请求包，对应的主机会回复这个应答</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>不可能TCP收到一个应答才发送下一个数据，因此引入了缓存空间【滑动窗口】。</p>
<p>流量控制： TCP告知对方还有多少容量，这样就可以控制发送的速度。</p>
<p>发送窗口（四块）：已发送且是否收到ack，未发送能否发送</p>
<p>接收窗口（三块）：是否接收到</p>
<p>GBN：计时器超时，只接受了0，2，3，下一次会发送4号帧</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>避免发送方填满网络，拥塞窗口</p>
<ul>
<li>慢启动：从1开始，指数级增长</li>
<li>拥塞发生：达到阈值后，线性增长</li>
<li>快速恢复：拥塞窗口可能置为0，可能置为一半+3【根据是否能收到三个连续的ack，意味着网络没有那么差】</li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>无连接，不可靠，数据包可能会丢失重复乱序；但是它是尽最大努力发送，所以速度快。</p>
<p>常用于音视频通讯</p>
<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h2 id="了解哪些集合"><a href="#了解哪些集合" class="headerlink" title="了解哪些集合"></a>了解哪些集合</h2><p>ArrayList，LinkedList（CopyOnWriteArrayList）；HashMap（ConcurrentHashMap）；HashSet</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>结构：数组+链表+红黑树</p>
<h3 id="put流程"><a href="#put流程" class="headerlink" title="put流程"></a>put流程</h3><p>根据散列算法计算数组下标：高16位和低16位异或，再&amp;对应的容量</p>
<p>散列到桶数组中，要么更新节点，要么插入链表尾节点或红黑树中。当链表&gt;8时，会转成红黑树</p>
<h3 id="扩容流程"><a href="#扩容流程" class="headerlink" title="扩容流程"></a>扩容流程</h3><p>每次put，当容量到达75%，会发生扩容。</p>
<p>由于容量是2的n次方，所以我们只需要判定最高位是否为1。如果是1的话，就移到原索引+原容量的位置；如果是0就不动。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>HashMap 为什么不安全</p>
<ul>
<li>两个<strong>同时put</strong>，应该用链表的，会被覆盖</li>
<li><strong>get和put</strong>同时，这时候rehash了，就get null了</li>
</ul>
<p>ConcurrentHashMap原理（<strong>synchronized</strong>锁桶数组上的节点）（<strong>自旋+CAS</strong>避免不必要的锁）</p>
<ul>
<li>get方法不用加锁，用volatile保证可见性</li>
<li>初始化数组：CAS+自旋 </li>
<li>散列到的数组下标是空：CAS+自旋 </li>
<li>其它的写入情况：synchronized</li>
<li>CAS+synchronized （进行扩容）</li>
</ul>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>写时复制，在写操作时，复制一个新的数组</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM的组织结构"><a href="#JVM的组织结构" class="headerlink" title="JVM的组织结构"></a>JVM的组织结构</h2><p>从上到下：类加载器；运行时数据区；垃圾回收期</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载的过程：</p>
<ul>
<li>加载（将.class文件加载到内存，并生成一个class对象）</li>
<li>连接：校验（字节流是否符合规范）、准备（静态变量默认值）、解析（直接指定实际的内存地址）</li>
<li>初始化：类变量的初始化</li>
</ul>
<p>双亲委派机制：</p>
<ul>
<li>启动、扩展、应用、自定义</li>
<li>从下往上递归，尽可能让父类去加载，只有当父类找不到指定的类，才会让子类去执行</li>
</ul>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>所有线程共享的数据区</p>
<ul>
<li>方法区：类信息、静态变量</li>
<li>堆：所有的对象</li>
</ul>
<p>线程隔离的数据区</p>
<ul>
<li>程序计数器：指向当前线程执行的字节码的行号</li>
<li>虚拟机栈：每执行一个方法都会开启一个栈帧（局部变量、操作数、出口）</li>
</ul>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="不可达判断："><a href="#不可达判断：" class="headerlink" title="不可达判断："></a>不可达判断：</h4><p>从一组GCROOTS的根对象（栈帧中的局部变量、类静态变量），进行递归搜索。</p>
<h4 id="垃圾回收算法："><a href="#垃圾回收算法：" class="headerlink" title="垃圾回收算法："></a>垃圾回收算法：</h4><p>标记清除、标记复制、标记整理</p>
<h4 id="G1："><a href="#G1：" class="headerlink" title="G1："></a>G1：</h4><p>将堆划分为大小相等的区，然后维护一个优先级列表，优先选择回收价值最大的进行回收。</p>
<p>初始标记(STW)；并发标记；最终标记(STW)；筛选回收。</p>
<p>可预测的停顿（停顿预测模型）：垃圾回收会STW，用户可以指定期望停顿时间、G1会尽可能在这个时间内完成垃圾回收</p>
<p>如何确定GC对象：每个region有一个Rset记录了谁引用了我，有card table记录了我引用了谁；只要扫描RSet（记录了GC的要收集的对象集合）</p>
<h2 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h2><p>分配内存，初始化零值，设置对象头（哪个类，哈希码），初始化</p>
<h2 id="内存分配方法"><a href="#内存分配方法" class="headerlink" title="内存分配方法"></a>内存分配方法</h2><p>指针碰撞：维护一个指针，每次向后移动一段距离</p>
<p>空闲列表：记录堆中所有未占用的内存块</p>
<h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><p>没有足够的内存</p>
<p>原因：创建的队列过大，线程池的任务队列无限队列，无线递归</p>
<p>导出Heap Dump文件，用Jprofile文件</p>
<h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="多线程可能存在的问题"><a href="#多线程可能存在的问题" class="headerlink" title="多线程可能存在的问题"></a>多线程可能存在的问题</h2><p>内存泄漏、死锁、线程不安全</p>
<h2 id="线程有几种创建方式"><a href="#线程有几种创建方式" class="headerlink" title="线程有几种创建方式"></a>线程有几种创建方式</h2><p>Runnable：重写run方法，void</p>
<p>Callable：重写call方法，有返回值的</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程：系统中的一个个应用（比如JVM进程）</p>
<p>线程：多个线程有独立的程序计数器、栈、本地方法栈；共用JVM进程的堆和方法区。</p>
<p>如何启动一个线程：start（）；线程池</p>
<h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>一个CPU处理多个线程，从用户的角度多个线程同时执行。</p>
<ul>
<li>采用时间片轮转，线程在时间片内占用cpu，用完后处于就绪状态让出cpu。</li>
<li>wait、sleep主动让出cpu</li>
<li>IO操作阻塞</li>
</ul>
<h2 id="线程安全使用场景-单例"><a href="#线程安全使用场景-单例" class="headerlink" title="线程安全使用场景-单例"></a>线程安全使用场景-单例</h2><p>饿汉式（直接在类加载时初始化）、懒汉式（双重校验锁、Enum、静态内部类）</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>主内存（共享变量）【主存】；</p>
<p> 每个线程私有的本地内存（共享变量的副本）【cpu里的L1缓存】</p>
<p>为什么要有本地内存：直接操作主内存会产生资源竞争；乱序更友好，让cpu有更大的自由度来乱序执行</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>无法透传，把变量保存在线程中。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>ThreadLocal 本身并不存储任何值，它只是作为一个映射，来映射线程的局部变量。线程维护一个ThreadLocalMap：&lt;ThreadLocal对象，局部变量&gt;</p>
<p>开放定值法，被占了直接找下一个就行</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>内存泄漏：kv对中的value是强引用，它并不会被回收。</p>
<p>解决方法：使用完记得remove</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>JMM中的主内存和线程本地内存</p>
<p>可见性（你的修改能被其他线程可见）：（写）强制刷到主内存，使得其它线程的本地内存失效，需要从主内存重新读。</p>
<ul>
<li>MESI（Modified, Exclusive, Shared, Invalid）：修改时，S&#x2F;E转为M，并广播Invalid信号</li>
</ul>
<p>有序性（防止cpu乱序导致的问题）：禁止指令重排</p>
<ul>
<li>写内存屏障（Store Barrier &#x2F; Write Barrier）： 当线程写入 volatile 变量时，JMM 会在写操作前插入 StoreStore 屏障，确保在这次写操作之前的所有普通写操作都已完成。接着在写操作后插入 StoreLoad 屏障，强制所有后来的读写操作都在此次写操作完成之后执行，这就确保了其他线程能立即看到 volatile 变量的最新值。</li>
<li>读内存屏障（Load Barrier &#x2F; Read Barrier）： 当线程读取 volatile 变量时，JMM 会在读操作前插入 LoadLoad 屏障，确保在此次读操作之前的所有读操作都已完成。而在读操作后插入 LoadStore 屏障，防止在此次读操作之后的写操作被重排序到读操作之前，这样就确保了对 volatile 变量的读取总是能看到之前对同一变量或其他相关变量的写入结果。</li>
</ul>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>修饰方法，修饰代码块</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>JVM底层实现（monitorenter。monitorexit），ObjectMonienter（enterSet，waitSet，owner）</p>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>无锁</p>
<p>偏向锁（只有一个线程）：对象头存了线程id，同一线程再次请求就无需再次同步。</p>
<p>轻量锁（多个线程，交替执行）：CAS修改对象头的MarkWord。自旋等待锁释放。</p>
<p>重量级锁：ObjectMonienter，mutex，涉及上下文切换，最耗时。</p>
<h2 id="ReentrantLock-（AQS）"><a href="#ReentrantLock-（AQS）" class="headerlink" title="ReentrantLock （AQS）"></a>ReentrantLock （AQS）</h2><p>通过AQS实现：volatile int变量（state）+ FIFO的双端队列</p>
<p>线程尝试cas修改state，如果成功就代表获取到锁；如果失败就去队列尾部自旋等待。</p>
<p>公平锁&#x2F;非公平锁【体现在竞争锁是否需要判断AQS中存在等待的线程】；lock&#x2F;trylock</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>乐观锁的实现方式：原子操作，Compare-and-Swap</p>
<p>问题ABA：A改成了B，又改回了A【用时间戳解决】</p>
<p>其它问题：一直自旋；只能保证一个变量</p>
<h2 id="乐观锁和悲观锁的选择"><a href="#乐观锁和悲观锁的选择" class="headerlink" title="乐观锁和悲观锁的选择"></a>乐观锁和悲观锁的选择</h2><p>悲观锁：</p>
<ul>
<li><p>假设最坏的场景-共享数据会被修改</p>
</li>
<li><p>高并发写操作频繁，直接锁定数据保证强一致性，涉及多个表的复杂事务操作</p>
</li>
</ul>
<p>乐观锁：</p>
<ul>
<li>假设最好的场景-共享数据没有被修改，但是在更新的时候会进行条件判断</li>
<li>需要高并发的场景，redis库存扣减</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>互斥；持有并等待；不可剥夺；循环等待</p>
<p>如何避免：互斥不能破坏；一次性请求所有资源；主动释放；排序申请资源</p>
<p>Mysql事务死锁的例子：事务A获得第一条数据的行锁，事务B获得第二条数据的行锁，事务A抢第二条数据的行锁，事务B第一条数据的行锁。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>降低资源消耗，线程复用，频繁地创建和删除线程都是自愿开销</li>
<li>提高响应速度，任务到达时，无需等待线程创建</li>
<li>提高线程的可管理性，线程是稀缺资源，防止无限制地创建线程，造成大量的线程上下文切换</li>
</ul>
<h3 id="应用（大营销）"><a href="#应用（大营销）" class="headerlink" title="应用（大营销）"></a>应用（大营销）</h3><ul>
<li>项目背景：抽奖是高并发的，需要快速响应用户请求，（聚合查询奖品信息；定时任务更新库存）</li>
<li>核心线程数：cpu核的两倍，即云服务器4核 * 2&#x3D;8（有很多网络通信，数据库操作，所以是IO密集性任务，有较多的空闲线程）</li>
<li>最大线程数：8 * 2 &#x3D;16 </li>
<li>阻塞队列：SynchronousQueue（提交后立即交给等待的线程处理，提高响应速度）</li>
<li>拒绝策略：CallerRunsPolicy（由调用线程来执行该任务，保证了任务能成功执行）</li>
</ul>
<h3 id="线程池工作流程"><a href="#线程池工作流程" class="headerlink" title="线程池工作流程"></a>线程池工作流程</h3><p>核心线程—&gt; 任务队列 —&gt; 非核心线程 —&gt;拒绝策略</p>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>抛异常；让提交的任务执行；丢弃最老的任务；直接丢弃这个任务</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>有界队列；无界队列；SynchronousQueue；延迟队列</p>
<h3 id="线程池CompletableFuture"><a href="#线程池CompletableFuture" class="headerlink" title="线程池CompletableFuture"></a>线程池CompletableFuture</h3><ul>
<li>添加任务：runAsync（参数：runnable，线程池）</li>
<li>编排：thenCombine，thenAccept</li>
<li>等待所有任务执行完毕：allof().join()</li>
</ul>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="一条查询语句"><a href="#一条查询语句" class="headerlink" title="一条查询语句"></a>一条查询语句</h2><p>连接器，处理请求的连接</p>
<p>解析器，解析sql语句</p>
<p>优化器，看使用哪些索引</p>
<p>执行期调用Innodb引擎</p>
<h2 id="一条更新语句怎么执行"><a href="#一条更新语句怎么执行" class="headerlink" title="一条更新语句怎么执行"></a>一条更新语句怎么执行</h2><p>先连接器、解析器、优化器。</p>
<p>开始更新，执行器和Innodb引擎配合执行。</p>
<ul>
<li><p>执行器先找引擎获取对应的行，从磁盘中读取内存。</p>
</li>
<li><p>引擎把行数据返回执行器，修改成一条新的数据。</p>
</li>
<li><p>两阶段提交【保证redolog和binlog的数据一致性】：写入redolog并将状态更新为prepare，写入binlog，提交事务并将状态更新为commit</p>
</li>
</ul>
<h2 id="一个语句的问题，update-table-set-age-13-where-name-”w”"><a href="#一个语句的问题，update-table-set-age-13-where-name-”w”" class="headerlink" title="一个语句的问题，update table set age&#x3D;13 where name&#x3D;”w”"></a>一个语句的问题，update table set age&#x3D;13 where name&#x3D;”w”</h2><p>因为name没有建索引，所以会全表扫描。有可能会造成全表的锁定，会有过多的IO消耗，直接导致了内存的消耗。</p>
<h2 id="Innodb和MyISAM"><a href="#Innodb和MyISAM" class="headerlink" title="Innodb和MyISAM"></a>Innodb和MyISAM</h2><p>事务？行级锁？聚簇索引？</p>
<h2 id="三大日志"><a href="#三大日志" class="headerlink" title="三大日志"></a>三大日志</h2><p>binlog：存储的是逻辑SQL语句</p>
<p>redolog：物理页的修改操作</p>
<p>undolog：版本链，事务回滚</p>
<h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p>慢查询日志（slow_query_log）定位慢sql</p>
<p>Explain（看索引和要扫描的行数）：</p>
<ul>
<li>可能用到的索引possible_keys&#x2F;实际用到的索引key：优化器使用了错误的索引，没有用到覆盖索引</li>
<li>执行要遍历的行数rows&#x2F;有效执行的行数filtered：扫描的行数过多，无用列太多</li>
</ul>
<p>Profile：查看实际的资源开销，包含耗时、IO、上下文切换、CPU等</p>
<p>Optimizer Trace：更细节，真正优化器执行语句的解析优化的过程</p>
<h2 id="为什么要用索引"><a href="#为什么要用索引" class="headerlink" title="为什么要用索引"></a>为什么要用索引</h2><p>磁盘IO非常耗时，因此需要索引减少磁盘IO，直接跳到索引所在的数据行。B+树查询的效率非常高。</p>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>功能：主键，唯一索引、普通索引</p>
<p>数据结构：B+索引<br>存储位置：聚簇索引、非聚簇索引</p>
<h2 id="SQL优化的点"><a href="#SQL优化的点" class="headerlink" title="SQL优化的点"></a>SQL优化的点</h2><p>避免使用select *。</p>
<p>深分页用子查询或者延迟关联。</p>
<ul>
<li>SELECT * FROM t_order WHERE id &gt;&#x3D; (SELECT id FROM t_order limit 1000000, 1) LIMIT 10;</li>
<li>SELECT t1.* FROM t_order t1 INNER JOIN (SELECT id FROM t_order limit 1000000, 10) t2 ON t1.id &#x3D; t2.id;</li>
</ul>
<p>join：小表驱动大表、适当增加冗余字段</p>
<p>正确使用索引（如下）</p>
<h2 id="创建索引注意的点"><a href="#创建索引注意的点" class="headerlink" title="创建索引注意的点"></a>创建索引注意的点</h2><p>选择合适的列作为索引：用经常作为查询、排序条件的；不用区分度低的、频繁更新、无序的（uuid）</p>
<p>避免过多索引：</p>
<p>合理运用联合索引</p>
<h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><p>最左前缀匹配</p>
<p>负向条件不能用索引，!&#x3D;、&lt;&gt;、not in、not exists、not like</p>
<p>like，当%出现在左边时，索引会失效</p>
<p>orderby，确保orderby的列被索引覆盖，或者与where的索引不匹配</p>
<p>or，两边不一致且没有建立联合索引</p>
<p>函数，索引列上有函数</p>
<h2 id="B-树的好处"><a href="#B-树的好处" class="headerlink" title="B+树的好处"></a>B+树的好处</h2><p>B+树是一棵搜索树，非叶子节点只存索引，叶子节点是一个双向列表存储数据。</p>
<p>矮胖型：更少的磁盘IO</p>
<ol>
<li><p>非叶子节点只存索引：能存的索引更多，高度更低</p>
</li>
<li><p>叶子节点是一个双向列表存储数据：范围查询更方便</p>
</li>
<li><p>查询效率更稳定：相同深度</p>
</li>
</ol>
<h2 id="B-树能存多少条数据"><a href="#B-树能存多少条数据" class="headerlink" title="B+树能存多少条数据"></a>B+树能存多少条数据</h2><p>数据页16K，一个索引16字节，一个数据行1K字节</p>
<p>3层可以存2000W条数据：1000（16K&#x2F;16） * 1000 * 16 (16K&#x2F;1K)</p>
<h2 id="记录锁、间隙锁、临键锁"><a href="#记录锁、间隙锁、临键锁" class="headerlink" title="记录锁、间隙锁、临键锁"></a>记录锁、间隙锁、临键锁</h2><p>记录锁：必须为唯一索引且精准匹配</p>
<p>间隙锁、临键锁：必须为非唯一索引</p>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>存的数据；只存指针和索引（需要回表）</p>
<h2 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h2><p>联合索引，需要从最左列开始，不能跳过中间的列</p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>没有覆盖索引，需要回表。索引下推就是直接在遍历的索引就进行条件判断，而不是回表之后再进行条件判断。</p>
<h2 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h2><p>乐观锁、悲观锁：MVCC 和 行锁</p>
<p>读写锁：读锁（加了读锁，其他还能读不能写）；写锁（加了写锁，其他读写都不行）</p>
<p>行锁、表锁</p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p>A原子性：要么全部完成 、要么都不完成（undolog）</p>
<p>I隔离性：事务之间互不干扰（MVCC）</p>
<p>D持久性：redolog，undolog</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>读未提交：</p>
<p>读已提交：脏读（读到未提交的数据）</p>
<p>可重复读：可重复读（重复读的数据不一致）</p>
<p>串行化：幻读（读取一个区间，由于另一个事务的插入，导致新增一条新纪录）</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>用于实现RC和RR</p>
<p>实现方式：版本链+ReadView。</p>
<ul>
<li><p>版本链：数据行有两个隐式字段（事务ID和undolog指针），undolog指针构成了一条版本链记录之前的值。</p>
</li>
<li><p>ReadView：创建该事务的ID；活跃ID；最小ID；最大ID（那么小于最小的可以看到；大于最大的看不到；在两者之间的根据是否在活跃ID中判断，不在能看到）</p>
</li>
</ul>
<p>RC和RR的实现区别：RC（在每次生成ReadView）；RR（在第一次生成ReadView）</p>
<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><ul>
<li>对于主库<ul>
<li>更新binlog</li>
<li>dump线程向从库推送</li>
</ul>
</li>
<li>对于从库<ul>
<li>接收binlog，写入中继日志</li>
<li>SQL线程读取并执行这些SQL语句</li>
</ul>
</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>负载均衡：单表单库数据量过大（分表），连接数量过大（分库），导致性能下降。</p>
<p><strong>水平分库分表（根据用户id）</strong>（用户信息，发奖订单，积分订单，活动订单），垂直分库分表</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="Redis用来干嘛"><a href="#Redis用来干嘛" class="headerlink" title="Redis用来干嘛"></a>Redis用来干嘛</h3><ul>
<li>缓存<ul>
<li>String：各种东西，比如奖品，验证码</li>
<li>Hash：getMap，奖品概率查找表</li>
<li>List：所有的线程池信息</li>
</ul>
</li>
<li>延时队列（RDelayedQueue）</li>
<li>限流器（RRateLimiter）</li>
<li>分布式锁</li>
<li>发布，订阅</li>
</ul>
<h2 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h2><p>基于内存的数据存储：避免了磁盘IO</p>
<p>单线程模型：避免了线程切换和锁竞争</p>
<p>IO多路复用：一个线程处理多个IO请求（IO请求是需要向内核请求系统调用的，select&#x2F;epoll通过维护多个套接字避免了阻塞）</p>
<h3 id="Redis-的持久化方式？"><a href="#Redis-的持久化方式？" class="headerlink" title="Redis 的持久化方式？"></a>Redis 的持久化方式？</h3><p><strong>两个持久化方式</strong></p>
<ul>
<li>RDB（Redis DataBase）：异步创建数据集的快照，不会阻塞<ul>
<li>bgsava</li>
<li>redis.conf中配置命令，发生多少次变更，多少秒后触发一次RDB</li>
</ul>
</li>
<li>AOF（Append only file）：追加每个写操作到AOF文件中<ul>
<li>流程1:将所有写命令追加到AOF buffer中</li>
<li>流程2:持久化sync<ul>
<li>每条写指令&#x2F;每秒&#x2F;只在Redis关闭时执行</li>
</ul>
</li>
<li>流程3:重写<ul>
<li>直接将Redis重写成一系列写命令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="RDB-和-AOF-的区别？"><a href="#RDB-和-AOF-的区别？" class="headerlink" title="RDB 和 AOF 的区别？"></a>RDB 和 AOF 的区别？</h2><p>RDB，文件小，对性能影响较小，但是容易造成数据丢失（性能是首要指标）</p>
<p>AOF，文件大，实时性好，对性能影响较大（尽可能减少数据丢失）</p>
<p>混合持久化：在AOF重写的同时，生成一份RDB快照，这份快照作为AOF文件的一部分，最后再附加新的写入命令。</p>
<h2 id="高可用（主从复制）"><a href="#高可用（主从复制）" class="headerlink" title="高可用（主从复制）"></a>高可用（主从复制）</h2><p>主节点（写），从节点（读）</p>
<h2 id="高可用（哨兵）"><a href="#高可用（哨兵）" class="headerlink" title="高可用（哨兵）"></a>高可用（哨兵）</h2><p>实现主从复制的高可用，故障（主节点宕机）的自动转移</p>
<p>哨兵节点：监控数据节点</p>
<ul>
<li>定时监控：定时任务发送心跳包</li>
<li>主观下线和客观下线：发现心跳包没有回复；询问其他哨兵节点</li>
<li>故障转移：选出一个节点作为新的主节点，原来的主节点作为从节点</li>
</ul>
<h2 id="高可用（集群）"><a href="#高可用（集群）" class="headerlink" title="高可用（集群）"></a>高可用（集群）</h2><p>切片，把数据通过Key散列（CRC16 % 2^14）到哈希槽，再散列到不同的节点</p>
<h2 id="什么是缓存击穿、缓存穿透、缓存雪崩"><a href="#什么是缓存击穿、缓存穿透、缓存雪崩" class="headerlink" title="什么是缓存击穿、缓存穿透、缓存雪崩"></a>什么是缓存击穿、缓存穿透、缓存雪崩</h2><p><strong>缓存击穿</strong></p>
<p>热点数据不在缓存中，大量数据尽量，直达数据库。</p>
<p>解决方案</p>
<ul>
<li><p>预热</p>
</li>
<li><p>过期问题：发现缓存中没有，对A这个数据加锁，拿到缓存再返回给用户</p>
</li>
</ul>
<p><strong>缓存穿透</strong></p>
<p>查询根本不存在的数据，那么也会直达数据库</p>
<p>解决方案</p>
<ul>
<li>加一个布隆过滤器（适用海量数据的场景）<ul>
<li>告诉我们key一定不存在或者可能存在</li>
<li>也就是多个hash映射，只要有一个为0，就说明不存在</li>
</ul>
</li>
<li>加一个null</li>
</ul>
<p><strong>缓存雪崩</strong></p>
<p>缓存大量过期，或者缓存服务器宕机</p>
<p>解决方案</p>
<ul>
<li>集群部署</li>
<li>使用多级缓存（Redis不可用了，也可以用本地缓存）</li>
<li>设置不同的过期时间</li>
</ul>
<h2 id="怎么处理热key和大key"><a href="#怎么处理热key和大key" class="headerlink" title="怎么处理热key和大key"></a>怎么处理热key和大key</h2><p>热（短时间大量访问）：使用主从复制，打散到不同服务器；以及缓存击穿的问题</p>
<p>大：比如Hash过大，拆分</p>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>noeviction：默认策略，不进行任何数据淘汰，直接返回错误信息。适用于不能丢失数据的场景。</p>
<p>volatile-lru：从设置了过期时间的键中，使用 LRU 算法淘汰最不常用的键。</p>
<p>allkeys-lru：从所有键中，使用 LRU（最近最少使用）算法淘汰最不常用的键。适用于缓存场景，优先保留最近使用的数据。</p>
<p>allkeys-random：从所有键中随机淘汰键。</p>
<p>volatile-random：从设置了过期时间的键中随机淘汰键。</p>
<p>volatile-ttl：从设置了过期时间的键中淘汰即将过期（TTL，Time To Live，存活时间）的键。</p>
<p>allkeys-lfu：对所有的 key 使用 LFU 算法进行删除。</p>
<p>volatile-lfu：对设置了过期时间的 key 使用 LFU 算法进行删除。</p>
<h2 id="缓存和数据库一致性（旁路缓存模式）"><a href="#缓存和数据库一致性（旁路缓存模式）" class="headerlink" title="缓存和数据库一致性（旁路缓存模式）"></a>缓存和数据库一致性（旁路缓存模式）</h2><p>读：先读缓存，读不到了从数据库中读然后放入缓存</p>
<p>写：先写数据库，再删缓存</p>
<ul>
<li>缓存删除失败怎么办：用消息队列删</li>
</ul>
<h2 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h2><p>一个简易版的分布式锁：setnx加锁，并设置过期时间；lua脚本（判断锁的值是否相等，再删除，防止删除别人的锁）删除锁</p>
<p>锁续期：看门狗，只要线程还没执行完，看门狗会不断执行锁续期（lua脚本，判断是否为持锁线程，如果是就续期）。默认是定时任务每隔10s，将过期时间设置为30s</p>
<h2 id="Redisson延时队列"><a href="#Redisson延时队列" class="headerlink" title="Redisson延时队列"></a>Redisson延时队列</h2><p>基于zset实现，根据相应的过期时间作为分数。扫描Sortset中的过期元素，加入就绪消息列表。</p>
<h2 id="Redisson限流"><a href="#Redisson限流" class="headerlink" title="Redisson限流"></a>Redisson限流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RRateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(<span class="string">&quot;javaguide.limiter&quot;</span>);</span><br><span class="line"><span class="comment">// 尝试设置限流器的速率为每小时 100 次</span></span><br><span class="line"><span class="comment">// RateType 有两种，OVERALL是全局限流,ER_CLIENT是单Client限流（可以认为就是单机限流）</span></span><br><span class="line">rateLimiter.trySetRate(RateType.OVERALL, <span class="number">100</span>, <span class="number">1</span>, RateIntervalUnit.HOURS);</span><br><span class="line"><span class="comment">// 尝试在 5 秒内获取一个许可，如果成功则返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">// tryAcquire()是同步方法，对应的异步方法：tryAcquireAsync()</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> rateLimiter.tryAcquire(<span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>令牌桶算法：系统按照固定的速率向桶中添加令牌，只有拿到令牌才能执行</p>
<p>lua脚本：使用zset保存请求信息，这样可以判断时间戳有没有超过一个周期。如果有的话就可以生成令牌了。最后，查看是否有令牌能拿到，能拿到就decyby 1.</p>
<p>对比其他的，Sentinel，Spring Cloud Gateway</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>跳表，是一种实现了二分查找的链表。</p>
<p>传统链表，查找算法是O（n）。跳表，增加了多级索引，查找的时间复杂度是O(log n)的。</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>控制（成员变量的控制）翻转（配置文件+工厂）</p>
<p>目的：解耦合</p>
<p>实现方式：通过spring工厂读取配置文件，通过反射创建对象</p>
<ul>
<li>applicationContext.getBean()</li>
<li>读取配置文件BeanDefinition</li>
<li>通过反射创建对象</li>
<li>属性赋值</li>
</ul>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>面向切面编程，通过代理类为原始类增加共性的额外功能</p>
<p>好处：便于原始类的维护</p>
<p>实现方式：</p>
<ul>
<li>JDK动态代理：Proxy.newProxyInstance(类加载器，接口，InvocationHandler)</li>
<li>cglib动态代理：Enhancer（类加载器，类，MethodInteceptor）</li>
</ul>
<p>实际使用</p>
<ul>
<li>aspect：切面</li>
<li>pointcut：定义一个切点</li>
<li>around：定义要做的具体操作</li>
</ul>
<h2 id="用到的设计模式"><a href="#用到的设计模式" class="headerlink" title="用到的设计模式"></a>用到的设计模式</h2><p>工厂、代理、单例</p>
<h2 id="Bean生命周期（怎么依赖注入的）"><a href="#Bean生命周期（怎么依赖注入的）" class="headerlink" title="Bean生命周期（怎么依赖注入的）"></a>Bean生命周期（怎么依赖注入的）</h2><p>实例化（创建一个Bean的实例），属性赋值（执行setter方法），初始化（允许自定义执行的逻辑，比如init-method）、销毁（允许自定义的逻辑，比如destroy-method）</p>
<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>单例：存在线程安全问题，尽量不要用有状态的bean</p>
<p>原型：每次请求都会创建一个实例，因此不存在线程安全问题</p>
<h2 id="Bean的注入方式"><a href="#Bean的注入方式" class="headerlink" title="Bean的注入方式"></a>Bean的注入方式</h2><p>构造函数（更推荐，保证了依赖在对象创建时就被注入，且对象是不可变的）</p>
<p>Setter</p>
<p>autowird和resource</p>
<h2 id="Bean的循环依赖"><a href="#Bean的循环依赖" class="headerlink" title="Bean的循环依赖"></a>Bean的循环依赖</h2><p>A依赖B，B依赖A，就出现了循环依赖。</p>
<p>解决方式：三级缓存，这样可以直接去缓存里拿，而不是无限死循环</p>
<ul>
<li>一级缓存：完全实例化好的bean</li>
<li>二级缓存：实例化完成，但还没注入的bean，</li>
<li>三级缓存：bean工厂对象，用于提前标记对象</li>
<li>为什么要有三级缓存（BeanPostProcessor代理的存在，会直接覆盖掉二级缓存中的普通对象）</li>
</ul>
<h2 id="事务的传播"><a href="#事务的传播" class="headerlink" title="事务的传播"></a>事务的传播</h2><p>一个事务被另一个事务调用，那么怎么回滚</p>
<ul>
<li>required（默认）：内部事务直接加入外部事务（任何一个方法报错都回滚）</li>
<li>required_new：内部事务开一个独立的事务，并将当前事务挂起，独立的事务（互不干扰的）</li>
<li>nest：在嵌套事务内执行（内部事务不会导致外部事务的回滚）</li>
</ul>
<h2 id="Springboot-Starter优点"><a href="#Springboot-Starter优点" class="headerlink" title="Springboot Starter优点"></a>Springboot Starter优点</h2><p>内置各种Tomcat容器。</p>
<p>以前的spring开发需要大量的xml文件，导入jar。现在提供了一系列的Starter，可以直接从pom依赖中引入。</p>
<h2 id="Springboot-自动配置原理"><a href="#Springboot-自动配置原理" class="headerlink" title="Springboot 自动配置原理"></a>Springboot 自动配置原理</h2><p>自动装配：对于外部引用的jar包，定义了一套SPI接口规范，扫描META-INF&#x2F;spring.factories文件，将里面的功能配置进SpringBoot。</p>
<p>@SpringBootApplication-@EnableAutoConfiguration</p>
<ul>
<li>ImportSelector（手动配置）</li>
<li>加载META-INF&#x2F;spring.factories文件中对应的条目</li>
</ul>
<h2 id="Spring、SpringMVC、SpringBoot"><a href="#Spring、SpringMVC、SpringBoot" class="headerlink" title="Spring、SpringMVC、SpringBoot"></a>Spring、SpringMVC、SpringBoot</h2><p>Spring是最基础的框架， 利用IOC和AOP，解决了应用组件的解藕，解决了面向切面编程。</p>
<p>在此基础之上，开发了MVC框架，通过Model、View、Controller使得开发web应用变得很容易。</p>
<p>在此基础之上，springboot它实现了自动配置，通过封装starter来简化各种xml的配置。</p>
<p>springboot是承载者辅助简化 项目搭建流程，如果承载的是web项目，那么它承载的就是MVC框架。</p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h3 id="消息队列的三个好处"><a href="#消息队列的三个好处" class="headerlink" title="消息队列的三个好处"></a>消息队列的三个好处</h3><p><strong>异步处理，减少响应时间（以发奖为例）</strong></p>
<p>请求在写入消息队列就立即返回给用户了</p>
<p><strong>削峰，限流（以发奖为例）</strong></p>
<p>把要做的事务存储在消息队列中（压力转嫁到MQ），然后后端再慢慢根据自己的能力去消费这些消息，避免直接把后端服务打掉。</p>
<p><strong>解耦</strong></p>
<p>新增业务，只要对该类消息感兴趣，只需订阅该消息</p>
<h2 id="Kafka两种模式"><a href="#Kafka两种模式" class="headerlink" title="Kafka两种模式"></a>Kafka两种模式</h2><p>队列（点对点）：只发送给一个消费者</p>
<p>发布订阅：消息发送给所有消费者</p>
<h3 id="为什么选择Kafka（send，KafkaListener）"><a href="#为什么选择Kafka（send，KafkaListener）" class="headerlink" title="为什么选择Kafka（send，KafkaListener）"></a>为什么选择Kafka（send，KafkaListener）</h3><p>极致的性能，超高吞吐量（百万级）；可以实现高可用，可以做到0消息丢失的情况；生态系统的兼容性非常好</p>
<p>缺点，<strong>消息重复消费</strong>，造成轻微的影响。</p>
<h3 id="保证Kafka的消费顺序"><a href="#保证Kafka的消费顺序" class="headerlink" title="保证Kafka的消费顺序"></a>保证Kafka的消费顺序</h3><p>Kafka一个topic里包含多个partition，只保证partition分区中的消息有序。所以send的时候指定分区（或者使用对象id作为key）。</p>
<h3 id="保证Kafka的消息不丢失"><a href="#保证Kafka的消息不丢失" class="headerlink" title="保证Kafka的消息不丢失"></a>保证Kafka的消息不丢失</h3><p><strong>生产者丢失消息</strong></p>
<ol>
<li>send函数的返回值是ListenableFuture，添加回调函数，判定消息结果。</li>
<li>设置重试次数稍微大一点</li>
<li>将消息发送之前，写入task表，如果发送失败，定时任务去补偿。</li>
</ol>
<p><strong>消费者丢失消息</strong></p>
<p>偏移量，当消费者自动提交了偏移量，但是还没消费就挂掉了。改成手动提交偏移量。</p>
<p><strong>Kafka丢失消息</strong></p>
<p>Kafka挂掉，多副本机制，但消息还没有同步。</p>
<p>使用acks&#x3D;all，最安全的，但是延迟会很高</p>
<h3 id="Kafka如何保证消息不重复消费"><a href="#Kafka如何保证消息不重复消费" class="headerlink" title="Kafka如何保证消息不重复消费"></a>Kafka如何保证消息不重复消费</h3><ul>
<li>mysql幂等校验</li>
<li>最根本的原因，已经消费的数据没有成功提交offset，拉取到消息再提交</li>
</ul>
<h2 id="重试和死信队列"><a href="#重试和死信队列" class="headerlink" title="重试和死信队列"></a>重试和死信队列</h2><p>Kafka 消费者在默认配置下会进行最多 10 次 的重试，每次重试的时间间隔为 0，即立即进行重试。</p>
<p>当重试全部失败后，不会永久丢弃，会加入死信队列“原topic.dlh”。</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h2><p>#使用了预处理，利用?，能有效防止SQL注入；$会直接替换到SQL语句中，会产生SQL注入</p>
<h2 id="statement和preparedstatement"><a href="#statement和preparedstatement" class="headerlink" title="statement和preparedstatement"></a>statement和preparedstatement</h2><p>这其实是#{}的体现。</p>
<p>在<code>PreparedStatement</code>对象创建时就被发送到数据库进行预编译。然后，我们后面多次执行这条SQL语句，只需要执行set方法set方法就行</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="项目-责任链、组合规则树"><a href="#项目-责任链、组合规则树" class="headerlink" title="项目-责任链、组合规则树"></a>项目-责任链、组合规则树</h2><p>对于串行连续的规则过滤，用责任链。</p>
<p>好处：减少ifelse便于扩展；根据数据库的配置动态生成责任链。</p>
<p>实现：实现了一个链表并且每次去遍历，只是这里的链表节点是bean对象</p>
<h2 id="项目-工厂模式"><a href="#项目-工厂模式" class="headerlink" title="项目-工厂模式"></a>项目-工厂模式</h2><p>对于责任链和组合规则树的创建，采用简单工厂模式</p>
<p>好处：解耦，将对象的创建和使用解耦，我不需要知道这个对象是怎么创建的</p>
<h2 id="项目-模版模式"><a href="#项目-模版模式" class="headerlink" title="项目-模版模式"></a>项目-模版模式</h2><p>对于抽奖的整体流程，采用模版模式定义算法的骨架</p>
<p>好处：提高代码的复用性和可扩展性，定义了算法的骨架，由不同的子类去实现。</p>
<p>实现：抽象类定义算法的步骤，由子类具体实现</p>
<h2 id="项目-策略模式"><a href="#项目-策略模式" class="headerlink" title="项目-策略模式"></a>项目-策略模式</h2><p>对于抽到奖品的计算，采用策略模式，要么去散列表里找，要么二分搜索。</p>
<p>好处：减少if else</p>
<p>实现：定义一个接口，不同策略实现不同的策略实现类。</p>
<h2 id="spring-工厂、代理、单例"><a href="#spring-工厂、代理、单例" class="headerlink" title="spring-工厂、代理、单例"></a>spring-工厂、代理、单例</h2><h2 id="MyBatis-工厂、单例、代理、模版、策略模式"><a href="#MyBatis-工厂、单例、代理、模版、策略模式" class="headerlink" title="MyBatis-工厂、单例、代理、模版、策略模式"></a>MyBatis-工厂、单例、代理、模版、策略模式</h2><p>工厂（SqlSessionFactory）</p>
<p>单例（Configuration）</p>
<p>代理（DAO接口代理实现类）</p>
<p>模版（BaseExecutor、CachingExecutor、SimpleExecutor，套娃）</p>
<p>策略（TypeHandler、LongTypeHandler、StringTypeHandler）</p>
<h1 id="杂七杂八的"><a href="#杂七杂八的" class="headerlink" title="杂七杂八的"></a>杂七杂八的</h1><h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><p>首先DDD最重要的就是解耦，相比MVC来说虽然DDD在前期的代码开发量更大，但是其防腐的设计让后期的维护和扩展成本更低，其核心在于domain和infrastructure层的解耦，原本我的业务直接去接触POJO，现在做了一层1：1的转换关系，我domain层可能很多个模块，比如策略、返利、活动，业务需求一旦改变，我只修改所属层的Entity，而不需要改POJO，就不会把POJO撑的非常大，但是这层1：1的对应也让代码开发量更大，综合来说还是得看项目的需求。</p>
<ul>
<li><p>值对象&#x2F;实体对象&#x2F;聚合对象</p>
<ul>
<li><p>不产生数据变化的，对数据库不产生影响的，不具备唯一id和标识性的信息，就定义为值对象。用于描述对象属性的值，比如订单状态有多个值，我们用枚举来描述，就可以创建一个订单状态枚举值对象，便于拓展和统一的管理。</p>
</li>
<li><p>实体对象就是对数据库会产生影响的，具有唯一值的，和PO对象一 一 对应的，这种就定义为实体对象。</p>
</li>
<li><p>聚合对象通常来说和事务相关，要拿综合的数据做一个完整的事务，在聚合内保证事务的统一，在领域外保证事务的最终一致性。</p>
</li>
</ul>
</li>
<li><p>抽奖、返利是核心域；奖品、抽奖策略、积分是支撑域。业务模型就说说每个领域的聚合&#x2F;实体&#x2F;值对象、服务、仓储。 </p>
</li>
<li><p>依赖倒置的目的是为了让， Domain层和基础层解藕，Domain层完全控制接口的设计。比如某天数据库换了也只用改基础层。 </p>
</li>
<li><p>每个领域只是一个分包模块，互相调用直接注入对应领域的服务。</p>
</li>
</ul>
<h2 id="项目-数据库"><a href="#项目-数据库" class="headerlink" title="项目-数据库"></a>项目-数据库</h2><p>活动：活动表、活动商品sku（查询商品库存并扣减）、活动订单、用户活动账户（生成一笔订单，并更新用户活动账户）</p>
<ul>
<li><p>抽奖策略：（两个规则过滤，责任链和规则树）策略、策略奖品表、规则树模型（根节点、节点、边）</p>
</li>
<li><p>发奖：中奖记录表（最后发奖）</p>
</li>
</ul>
<p>返利：返利配置表、用户积分账户表、用户积分兑换订单表（用户扣减积分，生成一笔积分兑换订单）、用户活动账户（抽奖次数额度）</p>
<p>签到：返利配置表、用户积分账户表、用户返利订单表（用户增加积分，生成一笔返利订单）</p>
<h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>相比UUID64位更小，时间戳也有一定的连续性</p>
<p>分布式唯一ID（64位）hutool</p>
<ul>
<li>时间戳（41）</li>
<li>机器表示（workid，datacenter）（10）</li>
<li>自增序列（12）</li>
</ul>
<h2 id="xxl-job"><a href="#xxl-job" class="headerlink" title="xxl-job"></a>xxl-job</h2><p>流程：调度中心（xxl-job-admin）；执行器注册到调度中心；任务分配给适当的执行器节点执行。</p>
<p>调度策略：轮循（交给任意一个节点执行任务）；分片广播（为每个节点注册一个index，每个节点根据index执行任务）</p>
<h2 id="OkHttp3"><a href="#OkHttp3" class="headerlink" title="OkHttp3"></a>OkHttp3</h2><p>用他们来封装对http的调用。相比httpclient，OkHttp是一个现代的HTTP客户端，它提供了简洁的API更易用，性能类似（都很高效）。支持同步阻塞调用和异步调用。</p>
<h2 id="幂等性（一锁二判三更新）"><a href="#幂等性（一锁二判三更新）" class="headerlink" title="幂等性（一锁二判三更新）"></a>幂等性（一锁二判三更新）</h2><p>为什么需要幂等性：创建订单重复调用创建两笔订单？；扣减库存重复调用是否会多扣一次？</p>
<p>什么原因：消息重试，网络超时用户重新点击</p>
<p>场景：高并发抢红包（重复点击多少次，都显示已经抢过了）；高并发下单（避免重复订单）；高并发支付（支付平台会生成唯一的支付连接）</p>
<p>实现：先加分布式锁，再通过唯一性索引</p>
<h1 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h1><ol>
<li><p>如果100万个人抢100个库存</p>
<ol>
<li>可以看运气，直接把90万个人的请求丢弃</li>
</ol>
</li>
<li><p>Redis扣减成功怎么保证MySQL一定会扣减成功</p>
<ol>
<li>mq补偿；定时任务扫描redis；定时任务扫描订单量，和库存消耗对比，以订单量为准</li>
</ol>
</li>
<li><p>MySQL作为数据存储的关系数据库，怎么保证效率的</p>
<ol>
<li>创建有效的索引；连接池、减少创建和销毁连接的开销；</li>
</ol>
</li>
<li><p>分库分表怎么扩容</p>
<ol>
<li>一般会迁移4库、8库、16库。类似HashMap，为每个库增加一个从库进行主从同步，同步好修改分片规则，然后解除同步关系并把冗余的字段清除</li>
</ol>
</li>
<li><p>你分库分表了，怎么做一个汇总查询呢？</p>
<ol>
<li>使用 canal 通过 binlog 同步到 ES 提供聚合查询</li>
</ol>
</li>
<li><p>分库分表，如何进行深读分页</p>
<ol>
<li>从0开始获取到limit的所有数据，而不是offset，将所有数据读到内存里然后去归并排序。</li>
<li>禁止跳页，直接以上一页的最大值作为查询条件</li>
<li>使用 canal 通过 binlog 同步到 ES 提供聚合查询<ol>
<li>es倒排索引：检索文档进行分词得到多个词语和词条，然后将词语和文档ID进行关联</li>
</ol>
</li>
</ol>
</li>
<li><p>接口慢，如何排查</p>
<ol>
<li>Arthas（阿尔萨斯）trace追踪调用路径和时间，定位时间在哪个地方被消耗了。可能是mysql，redis或者逻辑实现，再针对性地优化。</li>
</ol>
</li>
<li><p>线程池如何set的</p>
<ol>
<li>调用线程池自带的set方法。我看了一下里面的代码，如果设置的核心线程数小，就会进行interrupt操作，我理解它和stop的区别就是会等待线程执行而不是直接stop。如果设置的核心线程数大了，就直接设置参数就行。</li>
</ol>
</li>
</ol>
<h1 id="场景设计题1-秒杀"><a href="#场景设计题1-秒杀" class="headerlink" title="场景设计题1 - 秒杀"></a>场景设计题1 - 秒杀</h1><p>瞬时高并发，只有少部分用户能抢到</p>
<h2 id="缓存热点商品数据"><a href="#缓存热点商品数据" class="headerlink" title="缓存热点商品数据"></a>缓存热点商品数据</h2><p>从缓存中查询商品，如果没有从数据库拿，再放入缓存。</p>
<p>缓存击穿：提前预热；从数据库拿的时候加分布式锁</p>
<p>缓存穿透：布隆过滤器；缓存null</p>
<h2 id="库存扣减"><a href="#库存扣减" class="headerlink" title="库存扣减"></a>库存扣减</h2><p>先decr，再判断，再加分段库存锁。</p>
<p>如果需要恢复库存？：因为dect并setnx没有办法简单的加一，可以换成incr。</p>
<h2 id="秒杀-下单支付-MQ异步"><a href="#秒杀-下单支付-MQ异步" class="headerlink" title="秒杀-下单支付 MQ异步"></a>秒杀-下单支付 MQ异步</h2><p>处理消息丢失：写入消息发送表，再消费完之后再更新消息发送表的状态；定时任务重新发送</p>
<p>重复消费：写入消息发送表<br>垃圾消息：定时任务重新发送消息的时候，先查一下消息发送表</p>
<p>（未支付）延迟消费：下单的同时发送MQ消息到一个延迟队列，然后到一定时间消费消息去查看时候未支付</p>
<h2 id="限流（基于用户id）"><a href="#限流（基于用户id）" class="headerlink" title="限流（基于用户id）"></a>限流（基于用户id）</h2><p>基于redisson的RRatelimiter的令牌桶算法进行限流，如果没有获得令牌就加入黑名单</p>
<h1 id="场景设计题2-短链"><a href="#场景设计题2-短链" class="headerlink" title="场景设计题2-短链"></a>场景设计题2-短链</h1><p>核心：是要生成一个唯一的短链，然后在数据库中存下短链和长链的映射，302重定向到长链。</p>
<p>生成流程：</p>
<ul>
<li><p>长链合法性校验：域名是否合法，参数是否合法</p>
</li>
<li><p>查询数据库是否有长链</p>
<ul>
<li>有就说明生成过了</li>
</ul>
</li>
<li><p>没有就哈希算法计算短链</p>
<ul>
<li>如果有哈希冲突 ，可以在 尾部跟一个分布式ID</li>
</ul>
</li>
<li><p>然后把短链和长链的映射存入数据库中</p>
<ul>
<li>数据库表结构：（id，长链，短链）</li>
</ul>
</li>
</ul>
<h1 id="场景设计题3-排行榜"><a href="#场景设计题3-排行榜" class="headerlink" title="场景设计题3 - 排行榜"></a>场景设计题3 - 排行榜</h1><p>集合+排序：Redis zset实现，我们需要做的就是指定score（如果有多个条件：拼接字符串）</p>
<ul>
<li>zrange：查看某个范围的排序</li>
<li>zrank：查看用户的排序</li>
<li>zscore：查看用户的分数</li>
</ul>
<p>如果数据量上亿，可以进行根据score进行分片</p>
<h1 id="场景设计题4-10亿订单号如何去重"><a href="#场景设计题4-10亿订单号如何去重" class="headerlink" title="场景设计题4 - 10亿订单号如何去重"></a>场景设计题4 - 10亿订单号如何去重</h1><p>使用布隆过滤器</p>
<h1 id="场景设计题5-订单超时自动取消"><a href="#场景设计题5-订单超时自动取消" class="headerlink" title="场景设计题5 - 订单超时自动取消"></a>场景设计题5 - 订单超时自动取消</h1><p>使用延时队列</p>
<h1 id="各种面经上看到的"><a href="#各种面经上看到的" class="headerlink" title="各种面经上看到的"></a>各种面经上看到的</h1><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类看成外部类的一个成员，可以任意访问外部类的成员</p>
<p>持有一个对外部类的引用（也就是内部类多了个成员变量 final OutterClass this$0;）</p>
<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>介绍学校、绩点。</p>
<p>在科研方面，</p>
<p>在大学期间，参与过多次的技术类赛事项目，获得了国家级奖项。并且能够熟练使用各类技术框架，开发一些项目，积累了丰富的开发经验。例如，我在简历中的第一个项目是抽奖项目，在其中能够熟练运用分库分表、redis和kafka等中间件处理高并发的场景。同时，我也学习着开发了一些简单的轮子组件，例如动态线程池。</p>
<h1 id="面试记录"><a href="#面试记录" class="headerlink" title="面试记录"></a>面试记录</h1><h2 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h2><p>Q：如何手写一个简单的http server</p>
<p>A：</p>
<p>Q：当四次挥手进行到close_wait的时候服务器突然宕机，那么这个连接是中断还是保持，是中断的话用的什么机制让它中断的</p>
<p>A：</p>
<p>Q：场景：用户打开app，购买火车票的过程涉及到哪些网络连接</p>
<p>A：</p>
<p>Q：场景：有一张订单表（订单ID，订单状态，创建时间），你需要查询某月不同状态的订单量，当然这个表的数据量很大。toc 和 tob 分别怎么解决。</p>
<p>A：tob，分片查，相当于按照日期依次查，多线程处理；toc，不要求强实时性和一致性，可以用redis记录订单量。</p>
<p>Q：场景： crud 四个操作分别怎么做保证redis和mysql的强一致性</p>
<p>A：说了先更新数据库再删缓存（面试官说这是课本知识，不能保证强一致性），提示用锁。</p>
<p>计算机网络、IOCAOP底层实现、in、kafka模式</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/31/kaifa/DDD/DDD1%E6%A6%82%E5%BF%B5%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="蔡正海">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="czh的学习小站">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | czh的学习小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/31/kaifa/DDD/DDD1%E6%A6%82%E5%BF%B5%E7%90%86%E8%AE%BA/" class="post-title-link" itemprop="url">【1开发】【架构】DDD</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="MVC的缺点"><a href="#MVC的缺点" class="headerlink" title="MVC的缺点"></a>MVC的缺点</h2><p>三层结构：<strong>Service+数据模型</strong>的开发模式，扁平的平铺的代码开发。加上贫血模型（只允许getter&#x2F;setter）的开发模式，让行为对象的不断<strong>交叉使用</strong>。</p>
<p>大杂烩，适用于前期简单快速的开发，后期不可维护。</p>
<p>所以，我们要用DDD，通过聚合、领域服务，不与别人耦合在一块。把原来的<strong>众多Service+数据模型</strong>，拆分为独立的有边界的领域模块，每个领域内创建自己的对象、仓储等等。<strong>DDD 前期需要付出更多的设计成本，但对于软件的长周期迭代，这样的好处是非常大的。</strong></p>
<h2 id="DDD的概念"><a href="#DDD的概念" class="headerlink" title="DDD的概念"></a>DDD的概念</h2><h3 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a>充血模型</h3><p>定义：充血可以是整个包结构，一个包下包括了用于实现此包 Service 服务所需的各类零部件（模型、仓储、工厂），也可以被看做充血模型。</p>
<h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><p>领域模型 &#x3D;  领域对象（实体、值对象、聚合）+仓储+领域服务</p>
<ul>
<li><p>领域对象</p>
<ul>
<li><p>实体：状态属性+行为动作（功能）</p>
</li>
<li><p>值对象：不可变</p>
</li>
<li><p>聚合：一组对象（事务中包含的所有实体）</p>
</li>
</ul>
</li>
<li><p>仓储</p>
<ul>
<li>依赖倒置，不直接引入外部的服务，而是通过定义借口的方式</li>
</ul>
</li>
</ul>
<h2 id="DDD四色建模（风暴事件）"><a href="#DDD四色建模（风暴事件）" class="headerlink" title="DDD四色建模（风暴事件）"></a>DDD四色建模（风暴事件）</h2><p>怎么建模呢，我们需要规范DDD的操作手段，让各个伙伴，在同一语言下完成系统建模。</p>
<p><strong>流程：</strong></p>
<ul>
<li>先画一下用例图</li>
<li>花费大量的时间，一起去找领域事件</li>
<li>然后，添加决策命令、领域对象、业务流程串联领域对象</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240728110317998.png" alt="image-20240728110317998"></p>
<p>操作手段（专有名词）：</p>
<ul>
<li>决策命令：用户发起的行为动作</li>
<li>领域事件：完成态</li>
<li>业务流程：</li>
<li>领域对象：实体对象、值对象、聚合对象</li>
<li>只读模型：数据库读操作</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/31/kaifa/project/Dynamic-thread-pool/%E5%8A%A8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="蔡正海">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="czh的学习小站">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | czh的学习小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/31/kaifa/project/Dynamic-thread-pool/%E5%8A%A8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A01/" class="post-title-link" itemprop="url">【1开发】动态线程池组件记录1 - 线程池调研</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">动态线程池组件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><blockquote>
<p>学习资料：Java线程池实现原理及其在美团业务中的实践</p>
</blockquote>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="线程池（是什么）"><a href="#线程池（是什么）" class="headerlink" title="线程池（是什么）"></a>线程池（是什么）</h2><p>池化思想管理线程，好处</p>
<ul>
<li><strong>降低资源消耗</strong>：重复利用已创建的线程</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，使用线程进行统一的分配、调优和监控</li>
<li><strong>提供更多更强大的功能</strong>：ScheduledThreadPoolExecutor</li>
</ul>
<h2 id="线程池解决的问题（为什么）"><a href="#线程池解决的问题（为什么）" class="headerlink" title="线程池解决的问题（为什么）"></a>线程池解决的问题（为什么）</h2><p>线程是稀缺资源，不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入</p>
<ul>
<li>频繁申请&#x2F;销毁资源，带来额外的消耗</li>
<li>对资源无限申请，易引发系统资源耗尽的风险</li>
</ul>
<p>池化思想：</p>
<ul>
<li>内存池</li>
<li>连接池</li>
<li>实例池</li>
</ul>
<h1 id="线程池核心设计与实现"><a href="#线程池核心设计与实现" class="headerlink" title="线程池核心设计与实现"></a>线程池核心设计与实现</h1><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240702154427652.png" alt="image-20240702154427652" style="zoom:50%;" />

<ul>
<li>顶层接口Exector：<ul>
<li>任务提交和任务执行解藕</li>
<li>用户只需要将Runnable提交到Executor中</li>
</ul>
</li>
<li>ExecutorService：<ul>
<li>补充执行任务的能力，生成Future</li>
<li>管控线程池，停止线程池的运行</li>
</ul>
</li>
<li>AbstractExecutorService：<ul>
<li>抽象类，串联执行任务的流程</li>
</ul>
</li>
<li>ThreadPoolExecutor<ul>
<li>实现类</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240702154449505.png" alt="image-20240702154449505"></p>
<p>线程池内部实际上构建了一个生产者消费者模型，将线程和任务两者解藕，缓冲任务，复用线程。</p>
<p>任务管理（生产者）</p>
<ul>
<li>直接申请线程执行任务</li>
<li>缓冲队列中等待线程执行</li>
<li>拒绝该任务</li>
</ul>
<p>线程管理（消费者）</p>
<ul>
<li>它们被统⼀维护在线程池内，根据任务请求进⾏线程的分配</li>
</ul>
<h2 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>维护两个值：运行状态（runState），工作线程数量（workerCount）</p>
<p>运行状态有五种：</p>
<ul>
<li>RUNNING：正常运行</li>
<li>SHUTDOWN：不再接收新任务，能继续处理</li>
<li>STOP：不接受新任务，中断线程</li>
<li>TIDYING：</li>
<li>TERMINATED</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240702154505795.png" alt="image-20240702154505795"></p>
<h2 id="任务执行机制"><a href="#任务执行机制" class="headerlink" title="任务执行机制"></a>任务执行机制</h2><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><ul>
<li>先看核心线程有没有满</li>
<li>再看阻塞队列</li>
<li>最后看最大线程数</li>
<li>都不行，就拒绝</li>
</ul>
<h3 id="任务缓冲（阻塞队列）"><a href="#任务缓冲（阻塞队列）" class="headerlink" title="任务缓冲（阻塞队列）"></a>任务缓冲（阻塞队列）</h3><p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240702154521689.png" alt="image-20240702154521689"></p>
<h3 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h3><p>⼀种是任务直接由新创建的线程执⾏。</p>
<p>另⼀种是线程从任务队列中获取任务然后执⾏，执⾏完任务的空闲线程会再次去从队列中申请任务再去执⾏。</p>
<h3 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h3><p>任务队列满，线程池满，采取任务拒绝策略</p>
<ul>
<li>丢弃任务，抛出异常</li>
<li>丢弃任务，不抛出异常</li>
<li>丢弃最前面的任务，提交被拒绝的任务</li>
<li>由调用线程处理该任务</li>
</ul>
<h2 id="Worker线程管理"><a href="#Worker线程管理" class="headerlink" title="Worker线程管理"></a>Worker线程管理</h2><p>thread是在调⽤构造⽅法时通过ThreadFactory来创建的线程，可以⽤来执⾏任务；firstTask⽤它来保存传⼊的第⼀个任务，这个任务可以有也可以为null。如果这个值是⾮空的，那么线程就会在启动初期⽴即执⾏这个任务，也就对应核⼼线程创建时的情况；如果这个值是null，那么就需要创建⼀个线程去执⾏任务列表（workQueue）中的任务，也就是⾮核⼼线程的创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"> <span class="keyword">final</span> Thread thread;<span class="comment">//Worker持有的线程</span></span><br><span class="line"> Runnable firstTask;<span class="comment">//初始化的任务，可以为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240702154538532.png" alt="image-20240702154538532">Worker集成AQS，独占锁，比如回收场景</p>
<ul>
<li>Lock方法一旦获取了锁，代表该线程在执行任务，不能中断回收</li>
<li>不是独占，空闲，可以回收</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240702154555686.png" alt="image-20240702154555686"></p>
<p>Worker线程执行任务</p>
<ol>
<li>while循环不断getTask()方法来获取任务<ol>
<li>如果getTask为null则跳出循环，销毁线程</li>
</ol>
</li>
<li>判断线程池是否stop</li>
<li>执行任务</li>
</ol>
<h1 id="实践场景"><a href="#实践场景" class="headerlink" title="实践场景"></a>实践场景</h1><h2 id="1-快速响应用户请求"><a href="#1-快速响应用户请求" class="headerlink" title="1 - 快速响应用户请求"></a>1 - 快速响应用户请求</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>实时请求，⽐如说⽤户要查看⼀个商品的信息，那么我们需要将商品维度的⼀系列信息如商品的价格、优惠、库存、图⽚等等聚合起来，展示给⽤户。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执⾏任务。</p>
<h2 id="2-快速处理批量任务"><a href="#2-快速处理批量任务" class="headerlink" title="2 - 快速处理批量任务"></a>2 - 快速处理批量任务</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>离线任务，需要快速执行，统计报表</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>不需要瞬时完成，吞吐量优先。设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这⾥，设置的线程数过多可能还会引发线程上下⽂切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/31/kaifa/project/Dynamic-thread-pool/%E5%8A%A8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="蔡正海">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="czh的学习小站">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | czh的学习小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/31/kaifa/project/Dynamic-thread-pool/%E5%8A%A8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A02/" class="post-title-link" itemprop="url">【1开发】动态线程池组件记录2 - 动态线程池的实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE/%E5%8A%A8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">动态线程池组件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h1><p>虽然线程池的参数配置有一些规范，但实际场景中，线程池的参数并不好一次就配置好。同时需要做监控处理，知道整个线程的消耗情况，所以需要动态线程池。</p>
<p>核心流程如下：</p>
<ul>
<li>线程池核心信息的获取，核心线程数、最大线程数、活跃线程数、队列类型、队列任务数、队列剩余可用任务数</li>
<li>设计 Redis 版本的注册中心，通过 SDK 上报方式到 Redis 注册中心，做统一的管理，让各个接入动态线程池的组件都能统一管理。</li>
<li>通过Redis 的发布订阅能力，通过推送指定的主题，让对应的应用上的 sdk 监听和处置线程池。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cccccc96/cloudimg/main/image-20240702173453723.png" alt="image-20240702173453723"></p>
<h2 id="流程1-如何采集应用中的线程池信息"><a href="#流程1-如何采集应用中的线程池信息" class="headerlink" title="流程1 如何采集应用中的线程池信息"></a>流程1 如何采集应用中的线程池信息</h2><p>首先，我们需要一个接口，能实现线程池的配置查询和配置更新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDynamicThreadPoolService</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;ThreadPoolConfigEntity&gt; <span class="title function_">queryThreadPoolList</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    ThreadPoolConfigEntity <span class="title function_">queryThreadPoolConfigByName</span><span class="params">(String threadPoolName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateThreadPoolConfig</span><span class="params">(ThreadPoolConfigEntity threadPoolConfigEntity)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，我们需要构建一个bean对象将上述接口注入进应用中。</p>
<ul>
<li>拿到应用的applicationContext和所有threadPoolExecutor</li>
<li>构造DynamicThreadPoolService</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;dynamicThreadPollService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DynamicThreadPoolService <span class="title function_">dynamicThreadPollService</span><span class="params">(ApplicationContext applicationContext, Map&lt;String, ThreadPoolExecutor&gt; threadPoolExecutorMap, RedissonClient redissonClient)</span> &#123;</span><br><span class="line">    applicationName = applicationContext.getEnvironment().getProperty(<span class="string">&quot;spring.application.name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(applicationName)) &#123;</span><br><span class="line">        applicationName = <span class="string">&quot;缺省的&quot;</span>;</span><br><span class="line">        logger.warn(<span class="string">&quot;动态线程池，启动提示。SpringBoot 应用未配置 spring.application.name 无法获取到应用名称！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取缓存数据，设置本地线程池配置</span></span><br><span class="line">    Set&lt;String&gt; threadPoolKeys = threadPoolExecutorMap.keySet();</span><br><span class="line">    <span class="keyword">for</span> (String threadPoolKey : threadPoolKeys) &#123;</span><br><span class="line">        <span class="type">ThreadPoolConfigEntity</span> <span class="variable">threadPoolConfigEntity</span> <span class="operator">=</span> redissonClient.&lt;ThreadPoolConfigEntity&gt;getBucket(RegistryEnumVO.THREAD_POOL_CONFIG_PARAMETER_LIST_KEY.getKey() + <span class="string">&quot;_&quot;</span> + applicationName + <span class="string">&quot;_&quot;</span> + threadPoolKey).get();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == threadPoolConfigEntity) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> threadPoolExecutorMap.get(threadPoolKey);</span><br><span class="line">        threadPoolExecutor.setCorePoolSize(threadPoolConfigEntity.getCorePoolSize());</span><br><span class="line">        threadPoolExecutor.setMaximumPoolSize(threadPoolConfigEntity.getMaximumPoolSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DynamicThreadPoolService</span>(applicationName, threadPoolExecutorMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动自动配置 resources&#x2F;META-INF&#x2F;spring.factories（spi）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=cn.czh.middleware.dynamic.thread.pool.sdk.config.DynamicThreadPoolAutoConfig</span><br></pre></td></tr></table></figure>



<h2 id="流程2-线程池数据上报"><a href="#流程2-线程池数据上报" class="headerlink" title="流程2 线程池数据上报"></a>流程2 线程池数据上报</h2><p>设置定时任务：线程池配置信息上报到Redis配置中心</p>
<blockquote>
<p>小bug：admin和组件里的涉及到redis解码，包名要保持一致</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reportThreadPoolConfigParameter</span><span class="params">(ThreadPoolConfigEntity threadPoolConfigEntity)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> RegistryEnumVO.THREAD_POOL_CONFIG_PARAMETER_LIST_KEY.getKey() + <span class="string">&quot;_&quot;</span> + threadPoolConfigEntity.getAppName() + <span class="string">&quot;_&quot;</span> + threadPoolConfigEntity.getThreadPoolName();</span><br><span class="line">    RBucket&lt;ThreadPoolConfigEntity&gt; bucket = redissonClient.getBucket(cacheKey);</span><br><span class="line">    bucket.set(threadPoolConfigEntity, Duration.ofDays(<span class="number">30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流程3-订阅发布消息，变更线程池"><a href="#流程3-订阅发布消息，变更线程池" class="headerlink" title="流程3 订阅发布消息，变更线程池"></a>流程3 订阅发布消息，变更线程池</h2><p>监听消息，更新线程池配置，重新上报。</p>
<p>具体的线程池更新，直接调用线程池的set函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(CharSequence charSequence, ThreadPoolConfigEntity threadPoolConfigEntity)</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;动态线程池，调整线程池配置。线程池名称:&#123;&#125; 核心线程数:&#123;&#125; 最大线程数:&#123;&#125;&quot;</span>, threadPoolConfigEntity.getThreadPoolName(), threadPoolConfigEntity.getPoolSize(), threadPoolConfigEntity.getMaximumPoolSize());</span><br><span class="line">    dynamicThreadPoolService.updateThreadPoolConfig(threadPoolConfigEntity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新后上报最新数据</span></span><br><span class="line">    List&lt;ThreadPoolConfigEntity&gt; threadPoolConfigEntities = dynamicThreadPoolService.queryThreadPoolList();</span><br><span class="line">    registry.reportThreadPool(threadPoolConfigEntities);</span><br><span class="line"></span><br><span class="line">    <span class="type">ThreadPoolConfigEntity</span> <span class="variable">threadPoolConfigEntityCurrent</span> <span class="operator">=</span> dynamicThreadPoolService.queryThreadPoolConfigByName(threadPoolConfigEntity.getThreadPoolName());</span><br><span class="line">    registry.reportThreadPoolConfigParameter(threadPoolConfigEntityCurrent);</span><br><span class="line">    logger.info(<span class="string">&quot;动态线程池，上报线程池配置：&#123;&#125;&quot;</span>, JSON.toJSONString(threadPoolConfigEntity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流程4-管理端工程搭建"><a href="#流程4-管理端工程搭建" class="headerlink" title="流程4 管理端工程搭建"></a>流程4 管理端工程搭建</h2><p>本质上，就是往数据中心发送一条更新线程池配置的消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;update_thread_pool_config&quot;, method = RequestMethod.POST)</span><br><span class="line">public Response&lt;Boolean&gt; updateThreadPoolConfig(@RequestBody ThreadPoolConfigEntity request) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        log.info(&quot;修改线程池配置开始 &#123;&#125; &#123;&#125; &#123;&#125;&quot;, request.getAppName(), request.getThreadPoolName(), JSON.toJSONString(request));</span><br><span class="line">        RTopic topic = redissonClient.getTopic(&quot;DYNAMIC_THREAD_POOL_REDIS_TOPIC&quot; + &quot;_&quot; + request.getAppName());</span><br><span class="line">        topic.publish(request);</span><br><span class="line">        log.info(&quot;修改线程池配置完成 &#123;&#125; &#123;&#125;&quot;, request.getAppName(), request.getThreadPoolName());</span><br><span class="line">        return Response.&lt;Boolean&gt;builder()</span><br><span class="line">                .code(Response.Code.SUCCESS.getCode())</span><br><span class="line">                .info(Response.Code.SUCCESS.getInfo())</span><br><span class="line">                .data(true)</span><br><span class="line">                .build();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        log.error(&quot;修改线程池配置异常 &#123;&#125;&quot;, JSON.toJSONString(request), e);</span><br><span class="line">        return Response.&lt;Boolean&gt;builder()</span><br><span class="line">                .code(Response.Code.UN_ERROR.getCode())</span><br><span class="line">                .info(Response.Code.UN_ERROR.getInfo())</span><br><span class="line">                .data(false)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2022 - 2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">蔡正海</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>



  





</body>
</html>
